<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hello</title>
    <url>/2020/01/10/hello/</url>
    <content><![CDATA[<p><img src="/2020/01/10/hello/ylj.jpg" alt></p>
<a id="more"></a>
<p>总有一天，会有一个人，看你写过的所有状态，读完写的所有微博，看你从小到大的所有照片，甚至去别的地方寻找关于你的信息，试着听你听的歌，走你走过的地方，看你喜欢看的书，品尝你总是大呼好吃的东西……只是想弥补上，你的青春。</p>
]]></content>
      <tags>
        <tag>emotion</tag>
      </tags>
  </entry>
  <entry>
    <title>rt-thread内核</title>
    <url>/2020/01/10/rt-thread/</url>
    <content><![CDATA[<p><img src="/2020/01/10/rt-thread/zz.jpg" alt></p>
<a id="more"></a>
<h2 id="嵌入式系统和RT-Thread"><a href="#嵌入式系统和RT-Thread" class="headerlink" title="嵌入式系统和RT-Thread"></a>嵌入式系统和RT-Thread</h2><p>在裸机系统中，所有的程序基本都是自己写的，所有的操作都是在一个无限的大循环里面实现。现实生活中的很多中小型的电子产品用的都是裸机系统，而且也能够满足需求。但是为什么还要学习RTOS 编程，偏偏还要整个操作系统进来。一是项目需要，随着产品要实现的功能越来越多，单纯的裸机系统已经不能够完美地解决问题，反而会使编程变得更加复杂，如果想降低编程的难度，我们可以考虑引入RTOS 实现多线程管理，这是使用RTOS 的最大优势。二是学习的需要，必须学习更高级的东西，实现更好的职业规划，为将来走向人生巅峰迎娶白富美做准备，而不是一味的在裸机编程上面死磕。作为一个合格的嵌入式软件工程师，学习是永远不能停歇的事，时刻都得为将来准备。书到用时方恨少，我希望机会来临时你不要有这种感觉。</p>
<p>可偏偏在10 几年前，在中国，有一个天赋异禀，倔强不屈的极客，他叫熊谱翔，编写了RT-Thread 初代内核，并联合中国开源社区的极客不断完善，推陈出新，经过10 几年的发展，如今占据国产RTOS 的鳌头，每年递增数十万的开发者，加上如今AI 和物联网等风口，让RT-Thread 有一统江湖之势，从今年完成A 轮数百万美元的融资就可以看出，在未来不出5 年，RT-Thread 将是你学习和做产品的不二之选。</p>
<h2 id="裸机系统和多线程系统"><a href="#裸机系统和多线程系统" class="headerlink" title="裸机系统和多线程系统"></a>裸机系统和多线程系统</h2><h3 id="裸机系统"><a href="#裸机系统" class="headerlink" title="裸机系统"></a>裸机系统</h3><p>裸机系统通常分成轮询系统和前后台系统</p>
<h5 id="轮询系统"><a href="#轮询系统" class="headerlink" title="轮询系统"></a>轮询系统</h5><p>轮询系统即是在裸机编程的时候，先初始化好相关的硬件，然后让主程序在一个死循环里面不断环，顺序地做各种事情。轮询系统是一种非常简单的软件结构，通常只适用于那些只需要顺序执行代码且不需要外部事件来驱动的就能完成的事情。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="comment">/* 硬件相关初始化 */</span></span><br><span class="line"> 	 HardWareInit();</span><br><span class="line"></span><br><span class="line">	 <span class="comment">/* 无限循环 */</span></span><br><span class="line">	 <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">	 	 <span class="comment">/* 处理事情1 */</span></span><br><span class="line">		 DoSomething1();</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* 处理事情2 */</span></span><br><span class="line">         DoSomething2();</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* 处理事情3 */</span></span><br><span class="line">         DoSomething3();</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="前后台系统"><a href="#前后台系统" class="headerlink" title="前后台系统"></a>前后台系统</h5><p>相比轮询系统，前后台系统是在轮询系统的基础上加入了中断。外部事件的响应在中断里面完成，事件的处理还是回到轮询系统中完成，中断在这里我们称为前台，main 函数里面的无限循环我们称为后台。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">int</span> flag1 = <span class="number">0</span>;</span><br><span class="line"><span class="number">2</span> <span class="keyword">int</span> flag2 = <span class="number">0</span>;</span><br><span class="line"><span class="number">3</span> <span class="keyword">int</span> flag3 = <span class="number">0</span>;</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">6 </span>&#123;</span><br><span class="line"><span class="number">7</span> <span class="comment">/* 硬件相关初始化 */</span></span><br><span class="line"><span class="number">8</span> HardWareInit();</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span> <span class="comment">/* 无限循环 */</span></span><br><span class="line"><span class="number">11</span> <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="number">12</span> <span class="keyword">if</span> (flag1) &#123;</span><br><span class="line"><span class="number">13</span> <span class="comment">/* 处理事情1 */</span></span><br><span class="line"><span class="number">14</span> DoSomething1();</span><br><span class="line"><span class="number">15</span> &#125;</span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">17</span> <span class="keyword">if</span> (flag2) &#123;</span><br><span class="line"><span class="number">18</span> <span class="comment">/* 处理事情2 */</span></span><br><span class="line"><span class="number">19</span> DoSomething2();</span><br><span class="line"><span class="number">20</span> &#125;</span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">22</span> <span class="keyword">if</span> (flag3) &#123;</span><br><span class="line"><span class="number">23</span> <span class="comment">/* 处理事情3 */</span></span><br><span class="line"><span class="number">24</span> DoSomething3();</span><br><span class="line"><span class="number">25</span> &#125;</span><br><span class="line"><span class="number">26</span> &#125;</span><br><span class="line"><span class="number">27</span> &#125;</span><br><span class="line"><span class="number">28</span></span><br><span class="line"><span class="number">29</span> <span class="function"><span class="keyword">void</span> <span class="title">ISR1</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">30 </span>&#123;</span><br><span class="line"><span class="number">31</span> <span class="comment">/* 置位标志位 */</span></span><br><span class="line"><span class="number">32</span> flag1 = <span class="number">1</span>;</span><br><span class="line"><span class="number">33</span> <span class="comment">/* 如果事件处理时间很短，则在中断里面处理</span></span><br><span class="line"><span class="comment">34 如果事件处理时间比较长，在回到前台处理 */</span></span><br><span class="line"><span class="number">35</span> DoSomething1();</span><br><span class="line"><span class="number">36</span> &#125;</span><br><span class="line"><span class="number">37</span></span><br><span class="line"><span class="number">38</span> <span class="function"><span class="keyword">void</span> <span class="title">ISR2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">39 </span>&#123;</span><br><span class="line"><span class="number">40</span> <span class="comment">/* 置位标志位 */</span></span><br><span class="line"><span class="number">41</span> flag2 = <span class="number">1</span>;</span><br><span class="line"><span class="number">42</span></span><br><span class="line"><span class="number">43</span> <span class="comment">/* 如果事件处理时间很短，则在中断里面处理</span></span><br><span class="line"><span class="comment">44 如果事件处理时间比较长，在回到前台处理 */</span></span><br><span class="line"><span class="number">45</span> DoSomething2();</span><br><span class="line"><span class="number">46</span> &#125;</span><br><span class="line"><span class="number">47</span></span><br><span class="line"><span class="number">48</span> <span class="function"><span class="keyword">void</span> <span class="title">ISR3</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">49 </span>&#123;</span><br><span class="line"><span class="number">50</span> <span class="comment">/* 置位标志位 */</span></span><br><span class="line"><span class="number">51</span> flag3 = <span class="number">1</span>;</span><br><span class="line"><span class="number">52</span></span><br><span class="line"><span class="number">53</span> <span class="comment">/* 如果事件处理时间很短，则在中断里面处理</span></span><br><span class="line"><span class="comment">54 如果事件处理时间比较长，在回到前台处理 */</span></span><br><span class="line"><span class="number">55</span> DoSomething3();</span><br><span class="line"><span class="number">56</span> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="多线程系统"><a href="#多线程系统" class="headerlink" title="多线程系统"></a>多线程系统</h3><p>相比前后台系统，多线程系统的事件响应也是在中断中完成的，但是事件的处理是在线程中完成的。在多线程系统中，线程跟中断一样，也具有优先级，优先级高的线程会被优先执行。当一个紧急的事件在中断被标记之后，如果事件对应的线程的优先级足够高，就会立马得到响应。相比前后台系统，多线程系统的实时性又被提高了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">int</span> flag1 = <span class="number">0</span>;</span><br><span class="line"><span class="number">2</span> <span class="keyword">int</span> flag2 = <span class="number">0</span>;</span><br><span class="line"><span class="number">3</span> <span class="keyword">int</span> flag3 = <span class="number">0</span>;</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">6 </span>&#123;</span><br><span class="line"><span class="number">7</span> <span class="comment">/* 硬件相关初始化 */</span></span><br><span class="line"><span class="number">8</span> HardWareInit();</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span> <span class="comment">/* OS 初始化 */</span></span><br><span class="line"><span class="number">11</span> RTOSInit();</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span> <span class="comment">/* OS 启动，开始多线程调度，不再返回 */</span></span><br><span class="line"><span class="number">14</span> RTOSStart();</span><br><span class="line"><span class="number">15</span> &#125;</span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">17</span> <span class="function"><span class="keyword">void</span> <span class="title">ISR1</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">18 </span>&#123;</span><br><span class="line"><span class="number">19</span> <span class="comment">/* 置位标志位 */</span></span><br><span class="line"><span class="number">20</span> flag1 = <span class="number">1</span>;</span><br><span class="line"><span class="number">21</span> &#125;</span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">23</span> <span class="function"><span class="keyword">void</span> <span class="title">ISR2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">24 </span>&#123;</span><br><span class="line"><span class="number">25</span> <span class="comment">/* 置位标志位 */</span></span><br><span class="line"><span class="number">26</span> flag2 = <span class="number">2</span>;</span><br><span class="line"><span class="number">27</span> &#125;</span><br><span class="line"><span class="number">28</span></span><br><span class="line"><span class="number">29</span> <span class="function"><span class="keyword">void</span> <span class="title">ISR3</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">30 </span>&#123;</span><br><span class="line"><span class="number">31</span> <span class="comment">/* 置位标志位 */</span></span><br><span class="line"><span class="number">32</span> flag3 = <span class="number">1</span>;</span><br><span class="line"><span class="number">33</span> &#125;</span><br><span class="line"><span class="number">34</span></span><br><span class="line"><span class="number">35</span> <span class="function"><span class="keyword">void</span> <span class="title">DoSomething1</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">36 </span>&#123;</span><br><span class="line"><span class="number">37</span> <span class="comment">/* 无限循环，不能返回 */</span></span><br><span class="line"><span class="number">38</span> <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="number">39</span> <span class="comment">/* 线程实体 */</span></span><br><span class="line"><span class="number">40</span> <span class="keyword">if</span> (flag1) &#123;</span><br><span class="line"><span class="number">41</span></span><br><span class="line"><span class="number">42</span> &#125;</span><br><span class="line"><span class="number">43</span> &#125;</span><br><span class="line"><span class="number">44</span> &#125;</span><br><span class="line"><span class="number">45</span></span><br><span class="line"><span class="number">46</span> <span class="function"><span class="keyword">void</span> <span class="title">DoSomething2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">47 </span>&#123;</span><br><span class="line"><span class="number">48</span> <span class="comment">/* 无限循环，不能返回 */</span></span><br><span class="line"><span class="number">49</span> <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="number">50</span> <span class="comment">/* 线程实体 */</span></span><br><span class="line"><span class="number">51</span> <span class="keyword">if</span> (flag2) &#123;</span><br><span class="line"><span class="number">52</span></span><br><span class="line"><span class="number">53</span> &#125;</span><br><span class="line"><span class="number">54</span> &#125;</span><br><span class="line"><span class="number">55</span> &#125;</span><br><span class="line"><span class="number">56</span></span><br><span class="line"><span class="number">57</span> <span class="function"><span class="keyword">void</span> <span class="title">DoSomething3</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">58 </span>&#123;</span><br><span class="line"><span class="number">59</span> <span class="comment">/* 无限循环，不能返回 */</span></span><br><span class="line"><span class="number">60</span> <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="number">61</span> <span class="comment">/* 线程实体 */</span></span><br><span class="line"><span class="number">62</span> <span class="keyword">if</span> (flag3) &#123;</span><br><span class="line"><span class="number">63</span></span><br><span class="line"><span class="number">64</span> &#125;</span><br><span class="line"><span class="number">65</span> &#125;</span><br><span class="line"><span class="number">66</span> &#125;</span><br></pre></td></tr></table></figure>

<p>相比前后台系统中后台顺序执行的程序主体，在多线程系统中，根据程序的功能，我们把这个程序主体分割成一个个独立的，无限循环且不能返回的小程序，这个小程序我们称之为线程。每个线程都是独立的，互不干扰的，且具备自身的优先级，它由操作系统调度管理。加入操作系统后，我们在编程的时候不需要精心地去设计程序的执行流，不用担心每个功能模块之间是否存在干扰。加入了操作系统，我们的编程反而变得简单了。整个系统随之带来的额外开销就是操作系统占据的那一丁点FLASH 和RAM。现如今，单片机的FLASH 和RAM是越来越大，完全足以抵挡RTOS 那点开销。</p>
<h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>在裸机系统中，系统的主体就是main 函数里面顺序执行的无限循环，这个无限循环里面CPU 按照顺序完成各种事情。在多线程系统中，我们根据功能的不同，把整个系统分割成一个个独立的且无法返回的函数，这个函数我们称为线程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">void</span> <span class="title">thread_entry</span> <span class="params">(<span class="keyword">void</span> *parg)</span></span></span><br><span class="line"><span class="function">2 </span>&#123;</span><br><span class="line"><span class="number">3</span> <span class="comment">/* 线程主体，无限循环且不能返回 */</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="number">5</span> <span class="comment">/* 线程主体代码 */</span></span><br><span class="line"><span class="number">6</span> &#125;</span><br><span class="line"><span class="number">7</span> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程栈"><a href="#线程栈" class="headerlink" title="线程栈"></a>线程栈</h4><p>在多线程系统中，每个线程都是独立的，互不干扰的，所以要为每个线程都分配独立的栈空间，这个栈空间通常是一个预先定义好的全局数组，也可以是动态分配的一段内存空间，但它们都存在于RAM 中。在多线程系统中，有多少个线程就需要定义多少个线程栈。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 定义线程栈 */</span></span><br><span class="line"><span class="keyword">rt_uint8_t</span> rt_flag1_thread_stack[<span class="number">512</span>]; (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">rt_uint8_t</span> rt_flag2_thread_stack[<span class="number">512</span>];</span><br></pre></td></tr></table></figure>

<h4 id="线程控制块"><a href="#线程控制块" class="headerlink" title="线程控制块"></a>线程控制块</h4><p>在裸机系统中，程序的主体是CPU 按照顺序执行的。而在多线程系统中，线程的执行是由系统调度的。系统为了顺利的调度线程，为每个线程都额外定义了一个线程控制块，这个线程控制块就相当于线程的身份证，里面存有线程的所有信息，比如线程的栈指针，线程名称，线程的形参等。有了这个线程控制块之后，以后系统对线程的全部操作都可以通过这个线程控制块来实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function">struct <span class="title">rt_thread</span> <span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">2 </span>&#123;</span><br><span class="line"><span class="number">3</span> <span class="keyword">void</span> *sp; <span class="comment">/* 线程栈指针 */</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">void</span> *entry; <span class="comment">/* 线程入口地址 */</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">void</span> *parameter; <span class="comment">/* 线程形参 */</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">void</span> *stack_addr; <span class="comment">/* 线程栈起始地址 */</span></span><br><span class="line"><span class="number">7</span> <span class="keyword">rt_uint32_t</span> stack_size; <span class="comment">/* 线程栈大小，单位为字节 */</span></span><br><span class="line"><span class="number">8</span> &#125;;</span><br><span class="line"><span class="number">9</span> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> *<span class="title">rt_thread_t</span>;</span> (<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h4 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h4><p>线程的栈，线程的函数实体，线程的控制块最终需要联系起来才能由系统进行统一调度。那么这个联系的工作就由线程初始化函数rt_thread_init()来实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">rt_err_t</span> rt_thread_init(struct rt_thread *thread, (<span class="number">1</span>)</span><br><span class="line"><span class="number">2</span> <span class="keyword">void</span> (*entry)(<span class="keyword">void</span> *parameter), (<span class="number">2</span>)</span><br><span class="line"><span class="number">3</span> <span class="keyword">void</span> *parameter, (<span class="number">3</span>)</span><br><span class="line"><span class="number">4</span> <span class="keyword">void</span> *stack_start, (<span class="number">4</span>)</span><br><span class="line"><span class="number">5</span> <span class="keyword">rt_uint32_t</span> stack_size) (<span class="number">5</span>)</span><br><span class="line"><span class="number">6</span> &#123;</span><br><span class="line"><span class="number">7</span> rt_list_init(&amp;(thread-&gt;tlist)); (<span class="number">6</span>)</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span> thread-&gt;entry = (<span class="keyword">void</span> *)entry; (<span class="number">7</span>)</span><br><span class="line"><span class="number">10</span> thread-&gt;parameter = parameter; (<span class="number">8</span>)</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span> thread-&gt;stack_addr = stack_start; (<span class="number">9</span>)</span><br><span class="line"><span class="number">13</span> thread-&gt;stack_size = stack_size; (<span class="number">10</span>)</span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">15</span> <span class="comment">/* 初始化线程栈，并返回线程栈指针 */</span> (<span class="number">11</span>)</span><br><span class="line"><span class="number">16</span> thread-&gt;sp =</span><br><span class="line"><span class="number">17</span> (<span class="keyword">void</span> *)rt_hw_stack_init( thread-&gt;entry,</span><br><span class="line"><span class="number">18</span> thread-&gt;parameter,</span><br><span class="line"><span class="number">19</span> (<span class="keyword">void</span> *)((<span class="keyword">char</span> *)thread-&gt;stack_addr + thread-&gt;stack_size - <span class="number">4</span>) );</span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">21</span> <span class="keyword">return</span> RT_EOK; (<span class="number">12</span>)</span><br><span class="line"><span class="number">22</span> &#125;</span><br></pre></td></tr></table></figure>

<p>在main 函数中创建两个flag 相关的线程实例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">2 </span>&#123;</span><br><span class="line"><span class="number">3</span> <span class="comment">/* 硬件初始化 */</span></span><br><span class="line"><span class="number">4</span> <span class="comment">/* 将硬件相关的初始化放在这里，如果是软件仿真则没有相关初始化代码 */</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span> <span class="comment">/* 初始化线程 */</span></span><br><span class="line"><span class="number">8</span> rt_thread_init( &amp;rt_flag1_thread, <span class="comment">/* 线程控制块 */</span></span><br><span class="line"><span class="number">9</span> flag1_thread_entry, <span class="comment">/* 线程入口地址 */</span></span><br><span class="line"><span class="number">10</span> RT_NULL, <span class="comment">/* 线程形参 */</span></span><br><span class="line"><span class="number">11</span> &amp;rt_flag1_thread_stack[<span class="number">0</span>], <span class="comment">/* 线程栈起始地址 */</span></span><br><span class="line"><span class="number">12</span> <span class="keyword">sizeof</span>(rt_flag1_thread_stack) ); <span class="comment">/* 线程栈大小，单位为字节</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span> <span class="comment">/* 初始化线程 */</span></span><br><span class="line"><span class="number">15</span> rt_thread_init( &amp;rt_flag2_thread, <span class="comment">/* 线程控制块 */</span></span><br><span class="line"><span class="number">16</span> flag2_thread_entry, <span class="comment">/* 线程入口地址 */</span></span><br><span class="line"><span class="number">17</span> RT_NULL, <span class="comment">/* 线程形参 */</span></span><br><span class="line"><span class="number">18</span> &amp;rt_flag2_thread_stack[<span class="number">0</span>], <span class="comment">/* 线程栈起始地址 */</span></span><br><span class="line"><span class="number">19</span> <span class="keyword">sizeof</span>(rt_flag2_thread_stack) ); <span class="comment">/* 线程栈大小，单位为字节 */</span></span><br></pre></td></tr></table></figure>

<h4 id="就绪列表"><a href="#就绪列表" class="headerlink" title="就绪列表"></a>就绪列表</h4><p>线程创建好之后，我们需要把线程添加到就绪列表里面，表示线程已经就绪，系统随时可以调度。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="comment">/* 线程就绪列表 */</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rt_list_t</span> rt_thread_priority_table[RT_THREAD_PRIORITY_MAX]; (<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>线程控制块里面有一个tlist 成员，数据类型为rt_list_t，我们将线程插入到就绪列表里面，就是通过将线程控制块的tlist 这个节点插入到就绪列表中来实现的。如果把就绪列表比作是晾衣杆，线程是衣服，那tlist 就是晾衣架，每个线程都自带晾衣架，就是为了把自己挂在各种不同的链表中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="comment">/* 初始化线程 */</span></span><br><span class="line"><span class="number">2</span> rt_thread_init( &amp;rt_flag1_thread, <span class="comment">/* 线程控制块 */</span></span><br><span class="line"><span class="number">3</span> flag1_thread_entry, <span class="comment">/* 线程入口地址 */</span></span><br><span class="line"><span class="number">4</span> RT_NULL, <span class="comment">/* 线程形参 */</span></span><br><span class="line"><span class="number">5</span> &amp;rt_flag1_thread_stack[<span class="number">0</span>], <span class="comment">/* 线程栈起始地址 */</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">sizeof</span>(rt_flag1_thread_stack) ); <span class="comment">/* 线程栈大小，单位为字节 */</span></span><br><span class="line"><span class="number">7</span> <span class="comment">/* 将线程插入到就绪列表 */</span></span><br><span class="line"><span class="number">8</span> rt_list_insert_before( &amp;(rt_thread_priority_table[<span class="number">0</span>]),&amp;(rt_flag1_thread.tlist) );</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span> <span class="comment">/* 初始化线程 */</span></span><br><span class="line"><span class="number">11</span> rt_thread_init( &amp;rt_flag2_thread, <span class="comment">/* 线程控制块 */</span></span><br><span class="line"><span class="number">12</span> flag2_thread_entry, <span class="comment">/* 线程入口地址 */</span></span><br><span class="line"><span class="number">13</span> RT_NULL, <span class="comment">/* 线程形参 */</span></span><br><span class="line"><span class="number">14</span> &amp;rt_flag2_thread_stack[<span class="number">0</span>], <span class="comment">/* 线程栈起始地址 */</span></span><br><span class="line"><span class="number">15</span> <span class="keyword">sizeof</span>(rt_flag2_thread_stack) ); <span class="comment">/* 线程栈大小，单位为字节 */</span></span><br><span class="line"><span class="number">16</span> <span class="comment">/* 将线程插入到就绪列表 */</span></span><br><span class="line"><span class="number">17</span> rt_list_insert_before( &amp;(rt_thread_priority_table[<span class="number">1</span>]),&amp;(rt_flag2_thread.tlist) );</span><br></pre></td></tr></table></figure>

<h4 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h4><p>调度器是操作系统的核心，其主要功能就是实现线程的切换，即从就绪列表里面找到优先级最高的线程，然后去执行该线程。</p>
<p>调度器在使用之前必须先初始化：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="comment">/* 初始化系统调度器 */</span></span><br><span class="line"><span class="number">2</span> <span class="function"><span class="keyword">void</span> <span class="title">rt_system_scheduler_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">3 </span>&#123;</span><br><span class="line"><span class="number">4</span> <span class="keyword">register</span> <span class="keyword">rt_base_t</span> offset; (<span class="number">1</span>)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span> <span class="comment">/* 线程就绪列表初始化 */</span></span><br><span class="line"><span class="number">8</span> <span class="keyword">for</span> (offset = <span class="number">0</span>; offset &lt; RT_THREAD_PRIORITY_MAX; offset ++) (<span class="number">2</span>)</span><br><span class="line"><span class="number">9</span> &#123;</span><br><span class="line"><span class="number">10</span> rt_list_init(&amp;rt_thread_priority_table[offset]);</span><br><span class="line"><span class="number">11</span> &#125;</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span> <span class="comment">/* 初始化当前线程控制块指针 */</span></span><br><span class="line"><span class="number">14</span> rt_current_thread = RT_NULL; (<span class="number">3</span>)</span><br><span class="line"><span class="number">15</span> &#125;</span><br></pre></td></tr></table></figure>

<p>我们把调度器初始化放在硬件初始化之后，线程创建之前:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">2 </span>&#123;</span><br><span class="line"><span class="number">3</span> <span class="comment">/* 硬件初始化 */</span></span><br><span class="line"><span class="number">4</span> <span class="comment">/* 将硬件相关的初始化放在这里，如果是软件仿真则没有相关初始化代码 */</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span> <span class="comment">/* 调度器初始化 */</span></span><br><span class="line"><span class="number">7</span> rt_system_scheduler_init();</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span> <span class="comment">/* 初始化线程 */</span></span><br><span class="line"><span class="number">11</span> rt_thread_init( &amp;rt_flag1_thread, <span class="comment">/* 线程控制块 */</span></span><br><span class="line"><span class="number">12</span> flag1_thread_entry, <span class="comment">/* 线程入口地址 */</span></span><br><span class="line"><span class="number">13</span> RT_NULL, <span class="comment">/* 线程形参 */</span></span><br><span class="line"><span class="number">14</span> &amp;rt_flag1_thread_stack[<span class="number">0</span>], <span class="comment">/* 线程栈起始地址 */</span></span><br><span class="line"><span class="number">15</span> <span class="keyword">sizeof</span>(rt_flag1_thread_stack) ); <span class="comment">/* 线程栈大小，单位为字节 */</span></span><br><span class="line"><span class="number">16</span> <span class="comment">/* 将线程插入到就绪列表 */</span></span><br><span class="line"><span class="number">17</span> rt_list_insert_before( &amp;(rt_thread_priority_table[<span class="number">0</span>]),&amp;(rt_flag1_thread.tlist) );</span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">19</span> <span class="comment">/* 初始化线程 */</span></span><br><span class="line"><span class="number">20</span> rt_thread_init( &amp;rt_flag2_thread, <span class="comment">/* 线程控制块 */</span></span><br><span class="line"><span class="number">21</span> flag2_thread_entry, <span class="comment">/* 线程入口地址 */</span></span><br><span class="line"><span class="number">22</span> RT_NULL, <span class="comment">/* 线程形参 */</span></span><br><span class="line"><span class="number">23</span> &amp;rt_flag2_thread_stack[<span class="number">0</span>], <span class="comment">/* 线程栈起始地址 */</span></span><br><span class="line"><span class="number">24</span> <span class="keyword">sizeof</span>(rt_flag2_thread_stack) ); <span class="comment">/* 线程栈大小，单位为字节 */</span></span><br><span class="line"><span class="number">25</span> <span class="comment">/* 将线程插入到就绪列表 */</span></span><br><span class="line"><span class="number">26</span> rt_list_insert_before( &amp;(rt_thread_priority_table[<span class="number">1</span>]),&amp;(rt_flag2_thread.tlist) );</span><br><span class="line"><span class="number">27</span> &#125;</span><br></pre></td></tr></table></figure>

<p>初始化调度器后，我们就可以启动调度器啦，调度器启动由函数rt_system_scheduler_start()来完成。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="comment">/* 启动系统调度器 */</span></span><br><span class="line"><span class="number">2</span> <span class="function"><span class="keyword">void</span> <span class="title">rt_system_scheduler_start</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">3 </span>&#123;</span><br><span class="line"><span class="number">4</span> <span class="keyword">register</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> *<span class="title">to_thread</span>;</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span> <span class="comment">/* 手动指定第一个运行的线程 */</span> (<span class="number">1</span>)</span><br><span class="line"><span class="number">8</span> to_thread = rt_list_entry(rt_thread_priority_table[<span class="number">0</span>].next,</span><br><span class="line"><span class="number">9</span> struct rt_thread,</span><br><span class="line"><span class="number">10</span> tlist);</span><br><span class="line"><span class="number">11</span> rt_current_thread = to_thread; (<span class="number">2</span>)</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span> <span class="comment">/* 切换到第一个线程，该函数在context_rvds.S 中实现，</span></span><br><span class="line"><span class="comment">14 在rthw.h 声明，用于实现第一次线程切换。</span></span><br><span class="line"><span class="comment">15 当一个汇编函数在C 文件中调用的时候，如果有形参，</span></span><br><span class="line"><span class="comment">16 则执行的时候会将形参传人到CPU 寄存器r0。*/</span></span><br><span class="line"><span class="number">17</span> rt_hw_context_switch_to((<span class="keyword">rt_uint32_t</span>)&amp;to_thread-&gt;sp); (<span class="number">3</span>)</span><br><span class="line"><span class="number">18</span> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="临界段"><a href="#临界段" class="headerlink" title="临界段"></a>临界段</h4><p>临界段用一句话概括就是一段在执行的时候不能被中断的代码段。在RT-Thread 里面，这个临界段最常出现的就是对全局变量的操作，全局变量就好像是一个枪把子，谁都可以对他开枪，但是我开枪的时候，你就不能开枪，否则就不知道是谁命中了靶子。那么什么情况下临界段会被打断？一个是系统调度，还有一个就是外部中断。在RTThread，系统调度，最终也是产生PendSV 中断，在PendSV Handler 里面实现线程的切换，所以还是可以归结为中断。既然这样，RT-Thread 对临界段的保护就处理的很干脆了，直接把中断全部关了，NMI FAULT 和硬FAULT 除外。</p>
<h4 id="对象容器"><a href="#对象容器" class="headerlink" title="对象容器"></a>对象容器</h4><p>在RT-Thread 中，所有的数据结构都称之为对象。其中线程，信号量，互斥量、事件、邮箱、消息队列、内存堆、内存池、设备和定时器在rtdef.h 中有明显的枚举定义，即为每个对象打上了一个数字标签。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">enum</span> rt_object_class_type</span><br><span class="line"><span class="number">2</span> &#123;</span><br><span class="line"><span class="number">3</span> RT_Object_Class_Thread = <span class="number">0</span>, <span class="comment">/* 对象是线程 */</span></span><br><span class="line"><span class="number">4</span> RT_Object_Class_Semaphore, <span class="comment">/* 对象是信号量 */</span></span><br><span class="line"><span class="number">5</span> RT_Object_Class_Mutex, <span class="comment">/* 对象是互斥量 */</span></span><br><span class="line"><span class="number">6</span> RT_Object_Class_Event, <span class="comment">/* 对象是事件 */</span></span><br><span class="line"><span class="number">7</span> RT_Object_Class_MailBox, <span class="comment">/* 对象是邮箱 */</span></span><br><span class="line"><span class="number">8</span> RT_Object_Class_MessageQueue, <span class="comment">/* 对象是消息队列 */</span></span><br><span class="line"><span class="number">9</span> RT_Object_Class_MemHeap, <span class="comment">/* 对象是内存堆 */</span></span><br><span class="line"><span class="number">10</span> RT_Object_Class_MemPool, <span class="comment">/* 对象是内存池 */</span></span><br><span class="line"><span class="number">11</span> RT_Object_Class_Device, <span class="comment">/* 对象是设备 */</span></span><br><span class="line"><span class="number">12</span> RT_Object_Class_Timer, <span class="comment">/* 对象是定时器 */</span></span><br><span class="line"><span class="number">13</span> RT_Object_Class_Module, <span class="comment">/* 对象是模块 */</span></span><br><span class="line"><span class="number">14</span> RT_Object_Class_Unknown, <span class="comment">/* 对象未知 */</span></span><br><span class="line"><span class="number">15</span> RT_Object_Class_Static = <span class="number">0x80</span> <span class="comment">/* 对象是静态对象 */</span></span><br><span class="line"><span class="number">16</span> &#125;;</span><br></pre></td></tr></table></figure>

<h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><p>在rtt 中，每当用户创建一个对象，如线程，就会将这个对象放到一个叫做容器的地方，这样做的目的是为了方便管理，管理什么？在RT-Thread 的组件finsh 的使用中，就需要使用到容器，通过扫描容器的内核对象来获取各个内核对象的状态，然后输出调试信息。</p>
<p>从代码上看，容器就是一个数组，是一个全局变量，数据类型为struct_rt_object_information，在object.c 中定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">static</span> struct <span class="title">rt_object_information</span> <span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line">2 rt_object_container[RT_Object_Info_Unknown] = &#123; (2)</span><br><span class="line"><span class="number">3</span> <span class="comment">/* 初始化对象容器 - 线程 */</span> (<span class="number">3</span>)</span><br><span class="line"><span class="number">4</span> &#123;</span><br><span class="line"><span class="number">5</span> RT_Object_Class_Thread, (<span class="number">3</span>)-①</span><br><span class="line"><span class="number">6</span> _OBJ_CONTAINER_LIST_INIT(RT_Object_Info_Thread), (<span class="number">3</span>)-②</span><br><span class="line"><span class="number">7</span> <span class="keyword">sizeof</span>(struct rt_thread) (<span class="number">3</span>)-③</span><br><span class="line"><span class="number">8</span> &#125;,</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span> <span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_SEMAPHORE (4)</span></span><br><span class="line"><span class="number">11</span> <span class="comment">/* 初始化对象容器 - 信号量 */</span></span><br><span class="line"><span class="number">12</span> &#123;</span><br><span class="line"><span class="number">13</span> RT_Object_Class_Semaphore,</span><br><span class="line"><span class="number">14</span> _OBJ_CONTAINER_LIST_INIT(RT_Object_Info_Semaphore),</span><br><span class="line"><span class="number">15</span> <span class="keyword">sizeof</span>(struct rt_semaphore)</span><br><span class="line"><span class="number">16</span> &#125;,</span><br><span class="line"><span class="number">17</span> <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">19</span> <span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MUTEX (5)</span></span><br><span class="line"><span class="number">20</span> <span class="comment">/* 初始化对象容器 - 互斥量 */</span></span><br><span class="line"><span class="number">21</span> &#123;</span><br><span class="line"><span class="number">22</span> RT_Object_Class_Mutex,</span><br><span class="line"><span class="number">23</span> _OBJ_CONTAINER_LIST_INIT(RT_Object_Info_Mutex),</span><br><span class="line"><span class="number">24</span> <span class="keyword">sizeof</span>(struct rt_mutex)</span><br><span class="line"><span class="number">25</span> &#125;,</span><br><span class="line"><span class="number">26</span> <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="number">28</span> <span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_EVENT (6)</span></span><br><span class="line"><span class="number">29</span> <span class="comment">/* 初始化对象容器 - 事件 */</span></span><br><span class="line"><span class="number">30</span> &#123;</span><br><span class="line"><span class="number">31</span> RT_Object_Class_Event,</span><br><span class="line"><span class="number">32</span> _OBJ_CONTAINER_LIST_INIT(RT_Object_Info_Event),</span><br><span class="line"><span class="number">33</span> <span class="keyword">sizeof</span>(struct rt_event)</span><br><span class="line"><span class="number">34</span> &#125;,</span><br><span class="line"><span class="number">35</span> <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="number">36</span></span><br><span class="line"><span class="number">37</span> <span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MAILBOX (7)</span></span><br><span class="line"><span class="number">38</span> <span class="comment">/* 初始化对象容器 - 邮箱 */</span></span><br><span class="line"><span class="number">39</span> &#123;</span><br><span class="line"><span class="number">40</span> RT_Object_Class_MailBox,</span><br><span class="line"><span class="number">41</span> _OBJ_CONTAINER_LIST_INIT(RT_Object_Info_MailBox),</span><br><span class="line"><span class="number">42</span> <span class="keyword">sizeof</span>(struct rt_mailbox)</span><br><span class="line"><span class="number">43</span> &#125;,</span><br><span class="line"><span class="number">44</span> <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="number">45</span></span><br><span class="line"><span class="number">46</span> <span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MESSAGEQUEUE (8)</span></span><br><span class="line"><span class="number">47</span> <span class="comment">/* 初始化对象容器 - 消息队列 */</span></span><br><span class="line"><span class="number">48</span> &#123;</span><br><span class="line"><span class="number">49</span> RT_Object_Class_MessageQueue,</span><br><span class="line"><span class="number">50</span> _OBJ_CONTAINER_LIST_INIT(RT_Object_Info_MessageQueue),</span><br><span class="line"><span class="number">51</span> <span class="keyword">sizeof</span>(struct rt_messagequeue)</span><br><span class="line"><span class="number">52</span> &#125;,</span><br><span class="line"><span class="number">53</span> <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="number">54</span></span><br><span class="line"><span class="number">55</span> <span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MEMHEAP (9)</span></span><br><span class="line"><span class="number">56</span> <span class="comment">/* 初始化对象容器 - 内存堆 */</span></span><br><span class="line"><span class="number">57</span> &#123;</span><br><span class="line"><span class="number">58</span> RT_Object_Class_MemHeap,</span><br><span class="line"><span class="number">59</span> _OBJ_CONTAINER_LIST_INIT(RT_Object_Info_MemHeap),</span><br><span class="line"><span class="number">60</span> <span class="keyword">sizeof</span>(struct rt_memheap)</span><br><span class="line"><span class="number">61</span> &#125;,</span><br><span class="line"><span class="number">62</span> <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="number">63</span></span><br><span class="line"><span class="number">64</span> <span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MEMPOOL (10)</span></span><br><span class="line"><span class="number">65</span> <span class="comment">/* 初始化对象容器 - 内存池 */</span></span><br><span class="line"><span class="number">66</span> &#123;</span><br><span class="line"><span class="number">67</span> RT_Object_Class_MemPool,</span><br><span class="line"><span class="number">68</span> _OBJ_CONTAINER_LIST_INIT(RT_Object_Info_MemPool),</span><br><span class="line"><span class="number">69</span> <span class="keyword">sizeof</span>(struct rt_mempool)</span><br><span class="line"><span class="number">70</span> &#125;,</span><br><span class="line"><span class="number">71</span> <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="number">72</span></span><br><span class="line"><span class="number">73</span> <span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_DEVICE (11)</span></span><br><span class="line"><span class="number">74</span> <span class="comment">/* 初始化对象容器 - 设备 */</span></span><br><span class="line"><span class="number">75</span> &#123;</span><br><span class="line"><span class="number">76</span> RT_Object_Class_Device,</span><br><span class="line"><span class="number">77</span> _OBJ_CONTAINER_LIST_INIT(RT_Object_Info_Device),</span><br><span class="line"><span class="number">78</span> <span class="keyword">sizeof</span>(struct rt_device)</span><br><span class="line"><span class="number">79</span> &#125;,</span><br><span class="line"><span class="number">80</span> <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="number">81</span></span><br><span class="line"><span class="number">82</span> <span class="comment">/* 初始化对象容器 - 定时器 */</span> (<span class="number">12</span>)</span><br><span class="line"><span class="number">83</span> <span class="comment">/*</span></span><br><span class="line"><span class="comment">84 &#123;</span></span><br><span class="line"><span class="comment">85 RT_Object_Class_Timer,</span></span><br><span class="line"><span class="comment">86 _OBJ_CONTAINER_LIST_INIT(RT_Object_Info_Timer),</span></span><br><span class="line"><span class="comment">87 sizeof(struct rt_timer)</span></span><br><span class="line"><span class="comment">88 &#125;,</span></span><br><span class="line"><span class="comment">89 */</span></span><br><span class="line"><span class="number">90</span> <span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MODULE (13)</span></span><br><span class="line"><span class="number">91</span> <span class="comment">/* 初始化对象容器 - 模块 */</span></span><br><span class="line"><span class="number">92</span> &#123;</span><br><span class="line"><span class="number">93</span> RT_Object_Class_Module,</span><br><span class="line"><span class="number">94</span> _OBJ_CONTAINER_LIST_INIT(RT_Object_Info_Module),</span><br><span class="line"><span class="number">95</span> <span class="keyword">sizeof</span>(struct rt_module)</span><br><span class="line"><span class="number">96</span> &#125;,</span><br><span class="line"><span class="number">97</span> <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="number">98</span> &#125;;</span><br></pre></td></tr></table></figure>

<h4 id="对象初始化"><a href="#对象初始化" class="headerlink" title="对象初始化"></a>对象初始化</h4><p>每创建一个对象，都需要先将其初始化，主要分成两个部分的工作，首先将对象控制块里面与对象相关的成员初始化，然后将该对象插入到对象容器中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="comment">/**</span></span><br><span class="line"><span class="comment">2 * 该函数将初始化对象并将对象添加到对象容器中</span></span><br><span class="line"><span class="comment">3 *</span></span><br><span class="line"><span class="comment">4 * @param object 要初始化的对象</span></span><br><span class="line"><span class="comment">5 * @param type 对象的类型</span></span><br><span class="line"><span class="comment">6 * @param name 对象的名字，在整个系统中，对象的名字必须是唯一的</span></span><br><span class="line"><span class="comment">7 */</span></span><br><span class="line"><span class="number">8</span> <span class="function"><span class="keyword">void</span> <span class="title">rt_object_init</span><span class="params">(struct rt_object *object, (<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">9</span> <span class="keyword">enum</span> rt_object_class_type type, (<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">10</span> <span class="keyword">const</span> <span class="keyword">char</span> *name)</span> <span class="params">(<span class="number">3</span>)</span></span></span><br><span class="line"><span class="function">11 </span>&#123;</span><br><span class="line"><span class="number">12</span> <span class="keyword">register</span> <span class="keyword">rt_base_t</span> temp;</span><br><span class="line"><span class="number">13</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_object_information</span> *<span class="title">information</span>;</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">15</span> <span class="comment">/* 获取对象信息，即从容器里拿到对应对象列表头指针 */</span></span><br><span class="line"><span class="number">16</span> information = rt_object_get_information(type); (<span class="number">4</span>)</span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">18</span> <span class="comment">/* 设置对象类型为静态 */</span></span><br><span class="line"><span class="number">19</span> object-&gt;type = type | RT_Object_Class_Static; (<span class="number">5</span>)</span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">21</span> <span class="comment">/* 拷贝名字 */</span></span><br><span class="line"><span class="number">22</span> rt_strncpy(object-&gt;name, name, RT_NAME_MAX); (<span class="number">6</span>)</span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="number">24</span> <span class="comment">/* 关中断 */</span></span><br><span class="line"><span class="number">25</span> temp = rt_hw_interrupt_disable(); (<span class="number">7</span>)</span><br><span class="line"><span class="number">26</span></span><br><span class="line"><span class="number">27</span> <span class="comment">/* 将对象插入到容器的对应列表中，不同类型的对象所在的列表不一样 */</span></span><br><span class="line"><span class="number">28</span> rt_list_insert_after(&amp;(information-&gt;object_list), &amp;(object-&gt;<span class="built_in">list</span>)); (<span class="number">8</span>)</span><br><span class="line"><span class="number">29</span></span><br><span class="line"><span class="number">30</span> <span class="comment">/* 使能中断 */</span></span><br><span class="line"><span class="number">31</span> rt_hw_interrupt_enable(temp); (<span class="number">9</span>)</span><br><span class="line"><span class="number">32</span> &#125;</span><br></pre></td></tr></table></figure>

<p>对象初始化函数在线程初始化函数里面被调用。</p>
<h4 id="空闲线程"><a href="#空闲线程" class="headerlink" title="空闲线程"></a>空闲线程</h4><p>线程体内的延时使用的是软件延时，即还是让CPU 空等来达到延时的效果。使用RTOS 的很大优势就是榨干CPU 的性能，永远不能让它闲着，线程如果需要延时也就不能再让CPU 空等来实现延时的效果。RTOS 中的延时叫阻塞延时，即线程需要延时的时候，线程会放弃CPU 的使用权，CPU 可以去干其它的事情，当线程延时时间到，重新获取CPU 使用权，线程继续运行，这样就充分地利用了CPU 的资源，而不是干等着。</p>
<p>当线程需要延时，进入阻塞状态，那CPU 又去干什么事情了？如果没有其它线程可以运行，RTOS 都会为CPU 创建一个空闲线程，这个时候CPU 就运行空闲线程。在RTThread中，空闲线程是系统在初始化的时候创建的优先级最低的线程，空闲线程主体主要是做一些系统内存的清理工作。鉴于空闲线程的这种特性，在实际应用中，当系统进入空闲线程的时候，可在空闲线程中让单片机进入休眠或者低功耗等操作。</p>
<p>空闲线程也是线程，其定义方法和普通线程定义方法一样。</p>
<h5 id="定义空闲线程栈"><a href="#定义空闲线程栈" class="headerlink" title="定义空闲线程栈"></a>定义空闲线程栈</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;rtthread.h&gt;</span></span></span><br><span class="line"><span class="number">2</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;rthw.h&gt;</span></span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="meta">#<span class="meta-keyword">define</span> IDLE_THREAD_STACK_SIZE 512</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span> ALIGN(RT_ALIGN_SIZE)</span><br><span class="line"><span class="number">7</span> <span class="keyword">static</span> <span class="keyword">rt_uint8_t</span> rt_thread_stack[IDLE_THREAD_STACK_SIZE];</span><br></pre></td></tr></table></figure>

<h5 id="定义空闲线程的线程控制块"><a href="#定义空闲线程的线程控制块" class="headerlink" title="定义空闲线程的线程控制块"></a>定义空闲线程的线程控制块</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 空闲线程的线程控制块 */</span></span><br><span class="line"><span class="number">1</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> <span class="title">idle</span>;</span></span><br></pre></td></tr></table></figure>

<h5 id="定义空闲线程函数"><a href="#定义空闲线程函数" class="headerlink" title="定义空闲线程函数"></a>定义空闲线程函数</h5><p>在RT-Thread 中空闲线程函数主要是做一些系统内存的清理工作，但是为了简单起见，我们实现的空闲线程只是对一个全局变量rt_idletask_ctr 进行计数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">rt_ubase_t</span> rt_idletask_ctr = <span class="number">0</span>;</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="function"><span class="keyword">void</span> <span class="title">rt_thread_idle_entry</span><span class="params">(<span class="keyword">void</span> *parameter)</span></span></span><br><span class="line"><span class="function">4 </span>&#123;</span><br><span class="line"><span class="number">5</span> parameter = parameter;</span><br><span class="line"><span class="number">6</span> <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line"><span class="number">7</span> &#123;</span><br><span class="line"><span class="number">8</span> rt_idletask_ctr ++;</span><br><span class="line"><span class="number">9</span> &#125;</span><br><span class="line"><span class="number">10</span> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="空闲线程初始化"><a href="#空闲线程初始化" class="headerlink" title="空闲线程初始化"></a>空闲线程初始化</h5><p>当定义好空闲线程的栈，线程控制块和函数主体之后，我们需要空闲线程初始化函数将这三者联系在一起，这样空闲线程才能够被系统调度。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">void</span> <span class="title">rt_thread_idle_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">2 </span>&#123;</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="comment">/* 初始化线程 */</span> (<span class="number">1</span>)</span><br><span class="line"><span class="number">5</span> rt_thread_init(&amp;idle,</span><br><span class="line"><span class="number">6</span> <span class="string">"idle"</span>,</span><br><span class="line"><span class="number">7</span> rt_thread_idle_entry,</span><br><span class="line"><span class="number">8</span> RT_NULL,</span><br><span class="line"><span class="number">9</span> &amp;rt_thread_stack[<span class="number">0</span>],</span><br><span class="line"><span class="number">10</span> <span class="keyword">sizeof</span>(rt_thread_stack));</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span> <span class="comment">/* 将线程插入到就绪列表 */</span> (<span class="number">2</span>)</span><br><span class="line"><span class="number">13</span> rt_list_insert_before( &amp;(rt_thread_priority_table[RT_THREAD_PRIORITY_MAX<span class="number">-1</span>]),</span><br><span class="line"><span class="number">14</span> &amp;(idle.tlist) );</span><br><span class="line"><span class="number">15</span> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a>时间片</h4><p>在RT-Thread 中，当同一个优先级下有两个或两个以上线程的时候，线程支持时间片功能，即我们可以指定线程持续运行一次的时间，单位为tick。假如有两个线程分别为线程2 和线程3，他们的优先级都为3，线程2 的时间片为2，线程3 的时间片为3。当执行到优先级为3 的线程时，会先执行线程2，直到线程2 的时间片耗完，然后再执行线程3。</p>
<p>本次博客主要记录rt-thread的内核学习，下一篇记录应用。</p>
]]></content>
      <tags>
        <tag>learn</tag>
      </tags>
  </entry>
  <entry>
    <title>test</title>
    <url>/2020/01/08/test/</url>
    <content><![CDATA[<p><img src="/2020/01/08/test/bg.jpg" alt></p>
<a id="more"></a>
<p>路很长，雾很浓，但是，如果肯保有一颗谦卑与洁净的心，一定会在前路上找到一个更为开阔的世界，在那里，生命另有一种无法言传的尊严与价值。</p>
]]></content>
  </entry>
  <entry>
    <title>外骨骼控制</title>
    <url>/2020/01/08/exoskeleton1-1/</url>
    <content><![CDATA[<p><img src="/2020/01/08/exoskeleton1-1/yourname.jpg" alt></p>
<a id="more"></a>
<p>与传统机器人系统相比，这类可穿戴智能装备的最大特点，是通过在穿戴者肌骨神经运动控制生物系统与智能机电控制系统之间建立有效的物理和认知交互，使得两者在感知、决策和执行等多个层面融合与互补，最终构建综合一体化的具有“人在环”和“共融”特点的协同运动系统。对于这种高度复杂的人机系统而言，穿戴者不是可穿戴智能装备“被动的乘客”，而是一种全新的难以建模的交互对象，更是其结构与控制系统的重要组成部分。在这种新型人机交互系统的协同运动控制中，穿戴者借助自身肌骨神经运动系统自然的认知决策和运动行为，主导或部分参与人机系统从行为决策、整体位姿到关节运动轨迹等各层面的认知决策和运动规划。而可穿戴智能装备则通过传感系统感知穿戴者的运动状态与意图，控制各关节执行器实现相应的关节运动控制和动力补偿，最终实现人机系统协同的肢体运动和与外部环境的交互行为。相比于传统机器人系统纯粹基于预设控制算法决策与运动控制，这种人机交互系统将人体亿万年进化获得的认知智能和自然运动行为，与日益完善的智能化机电系统的传感技术和机械运动控制技术结合。这使得外骨骼这类可穿戴智能装备在获得前所未有的仿生性和环境自适应性的同时，成为穿戴者感知系统的延伸与肢体运动功能的拓展或补充。</p>
<p>对于助力类的外骨骼，几乎所有的控制信号输入都来源于穿戴者，而且需要对穿戴者的运动有良好的跟踪性能。这就要求外骨骼机器人的传感器系统能够高效准确地从复杂交互信号中提取人体的运动意图。</p>
]]></content>
      <categories>
        <category>外骨骼项目</category>
      </categories>
      <tags>
        <tag>think</tag>
      </tags>
  </entry>
</search>
