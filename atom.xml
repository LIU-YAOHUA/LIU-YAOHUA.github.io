<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>刘耀华博客</title>
  
  <subtitle>https://liu-yaohua.github.io</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liu-yaohua.github.io/"/>
  <updated>2020-01-21T07:35:52.438Z</updated>
  <id>https://liu-yaohua.github.io/</id>
  
  <author>
    <name>LIU-YAOHUA</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>english</title>
    <link href="https://liu-yaohua.github.io/2020/01/21/english/"/>
    <id>https://liu-yaohua.github.io/2020/01/21/english/</id>
    <published>2020-01-21T06:35:58.000Z</published>
    <updated>2020-01-21T07:35:52.438Z</updated>
    
    <content type="html"><![CDATA[<h1 id="英语学习资料汇总"><a href="#英语学习资料汇总" class="headerlink" title="英语学习资料汇总"></a>英语学习资料汇总</h1><h2 id="一起来感受学习的快乐吧！！！"><a href="#一起来感受学习的快乐吧！！！" class="headerlink" title="一起来感受学习的快乐吧！！！"></a>一起来感受学习的快乐吧！！！</h2><p><img src="/2020/01/21/english/%E5%88%9D%E9%9F%B3.jpg" alt></p><a id="more"></a><h2 id="雅思"><a href="#雅思" class="headerlink" title="雅思"></a>雅思</h2><ol><li><a href="https://pan.baidu.com/s/1niiVJ8WQ88-veUUGSL8lpg" target="_blank" rel="external nofollow noopener noreferrer">王陆807系列</a></li><li><a href="https://pan.baidu.com/s/18BhniBJ3g6zaboIuh-kQeA" target="_blank" rel="external nofollow noopener noreferrer">慎小嶷十天突破系列</a></li><li><a href="https://pan.baidu.com/s/1AVtBhTutE8ayoT4HqQKwww" target="_blank" rel="external nofollow noopener noreferrer">刘洪波阅读真经系列</a></li><li><a href="https://pan.baidu.com/s/1r8ovBKAgHR_DMqttta0KXA" target="_blank" rel="external nofollow noopener noreferrer">顾家北</a></li><li><a href="https://pan.baidu.com/s/1GSsGUY6BLrK_RvNRbQbnoA" target="_blank" rel="external nofollow noopener noreferrer">九分达人系列</a></li><li><a href="https://pan.baidu.com/s/1TmAC3rDLoTMH__ncqx5F9A" target="_blank" rel="external nofollow noopener noreferrer">Simon资料合集</a></li><li><a href="https://pan.baidu.com/s/1mjQhI8SR0jFW-BQbwXXEKQ" target="_blank" rel="external nofollow noopener noreferrer">1-4月雅思口语素材</a></li><li><a href="https://pan.baidu.com/s/1nuEDZII04fMMNNzJMD8IUg" target="_blank" rel="external nofollow noopener noreferrer">雅思王听力真题语料库（剑14）</a></li><li><a href="https://pan.baidu.com/s/1H_sjj9cgLHKgpXQjuoZbzQ" target="_blank" rel="external nofollow noopener noreferrer">郭娜听力</a></li><li><a href="https://pan.baidu.com/s/1PFR3sViqWmv_B1zSfD4AMA" target="_blank" rel="external nofollow noopener noreferrer">何琼听力</a></li><li><a href="https://pan.baidu.com/s/16hUsz22wVzzXJZVO-DnOVQ" target="_blank" rel="external nofollow noopener noreferrer">Amanda听力</a></li><li><a href="https://pan.baidu.com/s/1iQ2qDA30VTvAXfvmBmDF4Q" target="_blank" rel="external nofollow noopener noreferrer">王希伟阅读</a></li><li><a href="https://pan.baidu.com/s/1R3F9fggRRSf2-uYI5tt3vQ" target="_blank" rel="external nofollow noopener noreferrer">杜仕明写作</a></li></ol><h2 id="口语"><a href="#口语" class="headerlink" title="口语"></a>口语</h2><ol><li><a href="https://pan.baidu.com/s/1D-OafyRYOl11oUZ-HHkVMQ" target="_blank" rel="external nofollow noopener noreferrer">赖世雄美语从头学全系列</a></li><li><a href="https://pan.baidu.com/s/1vopMxAviQ3rH9jf-3Xou5A" target="_blank" rel="external nofollow noopener noreferrer">Rachel’s English</a></li><li><a href="https://pan.baidu.com/s/1UzTAQqpcqGUGHZZZwFkRjw" target="_blank" rel="external nofollow noopener noreferrer">BBC英音教程</a></li><li><a href="https://pan.baidu.com/s/1puehwSCzmwbSxdxQBNsgWA" target="_blank" rel="external nofollow noopener noreferrer">美音教程</a></li></ol><h2 id="万词班"><a href="#万词班" class="headerlink" title="万词班"></a>万词班</h2><ol><li><a href="https://pan.baidu.com/s/1Anu9U9DY8rG89TFxTTxJGA" target="_blank" rel="external nofollow noopener noreferrer">曲根万词</a></li><li><a href="https://pan.baidu.com/s/10l8xUe2Mje5nW09e_j15IA" target="_blank" rel="external nofollow noopener noreferrer">奇文词汇</a></li><li><a href="https://pan.baidu.com/s/1dc_nv-pK3XhBzg8H-VD_Iw" target="_blank" rel="external nofollow noopener noreferrer">新东方词汇进阶全系列</a></li></ol><h2 id="美剧"><a href="#美剧" class="headerlink" title="美剧"></a>美剧</h2><ol><li><a href="https://pan.baidu.com/s/12wyoQrwI2PALGRI5DaVc6g" target="_blank" rel="external nofollow noopener noreferrer">良医</a></li><li><a href="https://pan.baidu.com/s/1JgrFnEHfNlsn4UpbSAlOPA" target="_blank" rel="external nofollow noopener noreferrer">生活大爆炸全季</a></li></ol><h2 id="纪录片"><a href="#纪录片" class="headerlink" title="纪录片"></a>纪录片</h2><ol><li><a href="https://pan.baidu.com/s/1vzD9_Rnf0sRHBSSPw_5Jjw" target="_blank" rel="external nofollow noopener noreferrer">BBC</a></li></ol><h2 id="电影"><a href="#电影" class="headerlink" title="电影"></a>电影</h2><ol><li><a href="https://pan.baidu.com/s/1LOeUF3msfwLGwL_F36n68w" target="_blank" rel="external nofollow noopener noreferrer">漫威系列</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;英语学习资料汇总&quot;&gt;&lt;a href=&quot;#英语学习资料汇总&quot; class=&quot;headerlink&quot; title=&quot;英语学习资料汇总&quot;&gt;&lt;/a&gt;英语学习资料汇总&lt;/h1&gt;&lt;h2 id=&quot;一起来感受学习的快乐吧！！！&quot;&gt;&lt;a href=&quot;#一起来感受学习的快乐吧！！！&quot; class=&quot;headerlink&quot; title=&quot;一起来感受学习的快乐吧！！！&quot;&gt;&lt;/a&gt;一起来感受学习的快乐吧！！！&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2020/01/21/english/%E5%88%9D%E9%9F%B3.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="english" scheme="https://liu-yaohua.github.io/categories/english/"/>
    
    
      <category term="雅思" scheme="https://liu-yaohua.github.io/tags/%E9%9B%85%E6%80%9D/"/>
    
  </entry>
  
  <entry>
    <title>pcb</title>
    <link href="https://liu-yaohua.github.io/2020/01/21/pcb/"/>
    <id>https://liu-yaohua.github.io/2020/01/21/pcb/</id>
    <published>2020-01-21T06:29:58.000Z</published>
    <updated>2020-01-21T07:36:10.619Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原理图改动后更新PCB报错的解决方法"><a href="#原理图改动后更新PCB报错的解决方法" class="headerlink" title="原理图改动后更新PCB报错的解决方法"></a>原理图改动后更新PCB报错的解决方法</h1><p><img src="/2020/01/21/pcb/odrive.jpg" alt></p><a id="more"></a><p>遇到这种情况时大家往往束手无策而选择重新建立一个空白的PCB板再去生成一遍，其实，出现这种问题的原因有二。</p><p>其一，在我们第一次从原理图生成PCB时，软件就会生成器件之间连线的网表Netlists用以记录个器件之间的连接关系；其二，我们所建立的原理图文件在生成PCB时会被软件以原理图文件名作为分类名进行类的建立，也就是说我们建立的PCB工程下有几个原理图文件，则软件在生成PCB时，会将这些原理图文件一一分类，以各自的文件名建立各自的一个类进行管理。</p><p>所以，当我们遇到上述问题时，只需清楚网表，删除相关的类，就可以顺利的更新PCB文件了。</p><p>在PCB文件编辑器下：</p><p>1、Design—&gt;Netlist—&gt;Clear all nets；清除网表；</p><p>2、Design—&gt;Classes，在左侧的列表一栏，点击展开Component Classes，将相关的类右击选择Delete Class将其删除；</p><p>之后就可以顺利更新PCB了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;原理图改动后更新PCB报错的解决方法&quot;&gt;&lt;a href=&quot;#原理图改动后更新PCB报错的解决方法&quot; class=&quot;headerlink&quot; title=&quot;原理图改动后更新PCB报错的解决方法&quot;&gt;&lt;/a&gt;原理图改动后更新PCB报错的解决方法&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2020/01/21/pcb/odrive.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="pcb" scheme="https://liu-yaohua.github.io/categories/pcb/"/>
    
    
      <category term="pcb" scheme="https://liu-yaohua.github.io/tags/pcb/"/>
    
  </entry>
  
  <entry>
    <title>贴片封装尺寸和电容容值</title>
    <link href="https://liu-yaohua.github.io/2020/01/17/%E8%B4%B4%E7%89%87%E5%B0%81%E8%A3%85%E5%B0%BA%E5%AF%B8/"/>
    <id>https://liu-yaohua.github.io/2020/01/17/%E8%B4%B4%E7%89%87%E5%B0%81%E8%A3%85%E5%B0%BA%E5%AF%B8/</id>
    <published>2020-01-17T08:51:41.000Z</published>
    <updated>2020-01-17T09:00:07.315Z</updated>
    
    <content type="html"><![CDATA[<h2 id="smd贴片元件封闭尺寸"><a href="#smd贴片元件封闭尺寸" class="headerlink" title="smd贴片元件封闭尺寸"></a>smd贴片元件封闭尺寸</h2><p>公制：3216-2012-1608-1005-0603-0402</p><p>英制：1206-0805-0603-0402-0201-01005</p><h2 id="电容容值"><a href="#电容容值" class="headerlink" title="电容容值"></a>电容容值</h2><p><img src="/2020/01/17/%E8%B4%B4%E7%89%87%E5%B0%81%E8%A3%85%E5%B0%BA%E5%AF%B8/%E7%94%B5%E5%AE%B9%E5%AE%B9%E5%80%BC.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;smd贴片元件封闭尺寸&quot;&gt;&lt;a href=&quot;#smd贴片元件封闭尺寸&quot; class=&quot;headerlink&quot; title=&quot;smd贴片元件封闭尺寸&quot;&gt;&lt;/a&gt;smd贴片元件封闭尺寸&lt;/h2&gt;&lt;p&gt;公制：3216-2012-1608-1005-0603-0402&lt;/
      
    
    </summary>
    
    
      <category term="贴片" scheme="https://liu-yaohua.github.io/categories/%E8%B4%B4%E7%89%87/"/>
    
    
      <category term="pcb打样" scheme="https://liu-yaohua.github.io/tags/pcb%E6%89%93%E6%A0%B7/"/>
    
  </entry>
  
  <entry>
    <title>stm32_hal</title>
    <link href="https://liu-yaohua.github.io/2020/01/16/stm32-hal/"/>
    <id>https://liu-yaohua.github.io/2020/01/16/stm32-hal/</id>
    <published>2020-01-16T04:25:14.000Z</published>
    <updated>2020-01-16T07:59:32.456Z</updated>
    
    <content type="html"><![CDATA[<h1 id="stm32中的Hal库"><a href="#stm32中的Hal库" class="headerlink" title="stm32中的Hal库"></a>stm32中的Hal库</h1><a id="more"></a><h2 id="1-HAL库中-weak修饰符"><a href="#1-HAL库中-weak修饰符" class="headerlink" title="1.HAL库中__weak修饰符"></a>1.HAL库中__weak修饰符</h2><p>weak顾名思义是“弱”的意思，所以如果函数名称前面加上weak修饰符，我们一般称这个函数为“弱函数”。加上了weak修饰符的函数，用户可以在用户文件中重新定义一个同名函数，最终编译器编译的时候，会选择用户定义的函数，如果用户没有重新定义这个函数，那么编译器就会执行__weak声明的函数，并且编译器不会报错。</p><p>weak在回调函数的时候经常用到。这样的好处是，系统默认定义了一个空的回调函数，保证编译器不会报错。同时，如果用户自己要定义用户回调函数，那么只需要重新定义即可，不需要考虑函数重复定义的问题，使用非常方便，在HAL库中weak关键字被广泛使用。</p><p>00</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;stm32中的Hal库&quot;&gt;&lt;a href=&quot;#stm32中的Hal库&quot; class=&quot;headerlink&quot; title=&quot;stm32中的Hal库&quot;&gt;&lt;/a&gt;stm32中的Hal库&lt;/h1&gt;
    
    </summary>
    
    
      <category term="stm32" scheme="https://liu-yaohua.github.io/categories/stm32/"/>
    
    
      <category term="hal库" scheme="https://liu-yaohua.github.io/tags/hal%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>ble</title>
    <link href="https://liu-yaohua.github.io/2020/01/14/ble/"/>
    <id>https://liu-yaohua.github.io/2020/01/14/ble/</id>
    <published>2020-01-14T10:01:12.000Z</published>
    <updated>2020-01-20T05:35:06.094Z</updated>
    
    <content type="html"><![CDATA[<h1 id="nRF52832-BLE"><a href="#nRF52832-BLE" class="headerlink" title="nRF52832 BLE"></a>nRF52832 BLE</h1><p>随着物联网的发展，BLE蓝牙正在被广泛使用，几乎BLE配个安卓app已然成为现在物联网产品的标配，如小米手环，小米智能家居，小米电饭煲，更多的医疗产品。从技术角度看，与stm32嵌入式开发一般，并无大的区别，主要是加蓝牙协议，而不是单纯的单片机。NRF52832是我入门的第一款BLE蓝牙，所以我打算记录下我的学习过程。</p><a id="more"></a><h2 id="1-nRF52832芯片简介"><a href="#1-nRF52832芯片简介" class="headerlink" title="1.nRF52832芯片简介"></a>1.nRF52832芯片简介</h2><p>nRF52832芯片主要特点介绍。</p><ul><li>2.4GHz radio，支持多种无线协议，例如BLE，ANT等。</li><li>32位 ARM Cortex-M4F 处理器，增强浮点运算能力，可以提供更复杂的算力支持。</li><li>512KB程序存储空间和64KB内存空间。</li><li>31个GPIO，每个IO均可灵活配置。</li></ul><p>芯片功能框图如下图所示：</p><p><img src="/2020/01/14/ble/NRF52832_%E8%8A%AF%E7%89%87%E5%8A%9F%E8%83%BD%E6%A1%86%E5%9B%BE.png" alt="NRF52832_芯片功能框图"></p><p>nRF52832的学习分三块：</p><ul><li>基础实验，针对nRF52832芯片硬件外设的示例实验，例如GPIO实验，UART串口实验等。</li><li>协议栈实验，针对蓝牙协议栈的示例实验，例如蓝牙从机实验，蓝牙主机实验等。</li><li>协议栈高级实验，蓝牙实验的进阶，例如蓝牙主从一体，iBeacon等，更接近真实项目的示例程序。</li></ul><h2 id="2-新建工程"><a href="#2-新建工程" class="headerlink" title="2.新建工程"></a>2.新建工程</h2><p>新建工程目录结构如下：</p><ol><li><p>App文件夹：用于存放main.c文件和我们自己编写的应用程序文件。</p></li><li><p>Project文件夹：</p><p>Config文件夹：用于存放工程配置向导（sdk_config.h）</p><p>mdk5文件夹：用于存放工程文件</p><p>3.doc文件夹：用于存放说明之类的文档</p><p>4.components,integration,modules等：从sdk中拷贝的库文件</p></li></ol><p><img src="/2020/01/14/ble/project_structure.jpg" alt></p><h2 id="3-驱动led指示灯闪烁"><a href="#3-驱动led指示灯闪烁" class="headerlink" title="3.驱动led指示灯闪烁"></a>3.驱动led指示灯闪烁</h2><p>代码相比于stm32要简单一些，更像arduino,直接贴出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"nrf_delay.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"boards.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//配置用于驱动LED指示灯D1的引脚P0.17为输出</span></span><br><span class="line">    nrf_gpio_cfg_output(LED_1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//P0.17输出高电平，D1熄灭</span></span><br><span class="line">        nrf_gpio_pin_set(LED_1);</span><br><span class="line">        <span class="comment">//软件延时200ms</span></span><br><span class="line">        nrf_delay_ms(<span class="number">200</span>);</span><br><span class="line">        <span class="comment">//P0.17输出低电平，D1点亮</span></span><br><span class="line">        nrf_gpio_pin_clear(LED_1);</span><br><span class="line">        <span class="comment">//软件延时200ms</span></span><br><span class="line">        nrf_delay_(<span class="number">200</span>);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-BLE程序"><a href="#4-BLE程序" class="headerlink" title="4.BLE程序"></a>4.BLE程序</h2><h4 id="BLE包含两个部分：softdevice-application"><a href="#BLE包含两个部分：softdevice-application" class="headerlink" title="BLE包含两个部分：softdevice+application"></a>BLE包含两个部分：softdevice+application</h4><ol><li>softdevice:是蓝牙低功耗中心设备和外围设备协议栈解决方案，softdevice以hex文件提供，源码不对外公开，softdevice提供了api供用户调用，支持最多同时运行20个连接。</li><li>application：nordic提供的库和用户编写的程序。</li></ol><h3 id="BLE程序下载"><a href="#BLE程序下载" class="headerlink" title="BLE程序下载"></a>BLE程序下载</h3><p>下载softdevice的hex文件+应用程序编译后生成的目标文件</p><h3 id="裸机程序"><a href="#裸机程序" class="headerlink" title="裸机程序"></a>裸机程序</h3><ol><li>程序结构：只有nordic的库和用户自己编写的程序</li><li>程序下载：只需下载应用程序</li></ol><h3 id="nrf52xxx编程算法"><a href="#nrf52xxx编程算法" class="headerlink" title="nrf52xxx编程算法"></a>nrf52xxx编程算法</h3><p><img src="/2020/01/14/ble/nrf52xx%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95.jpg" alt="nrf52xx编程算法"></p><h3 id="裸机程序下载流程"><a href="#裸机程序下载流程" class="headerlink" title="裸机程序下载流程"></a>裸机程序下载流程</h3><p><img src="/2020/01/14/ble/%E8%A3%B8%E6%9C%BA%E7%A8%8B%E5%BA%8F%E4%B8%8B%E8%BD%BD%E6%B5%81%E7%A8%8B.jpg" alt="裸机程序下载流程"></p><h3 id="BLE程序下载流程"><a href="#BLE程序下载流程" class="headerlink" title="BLE程序下载流程"></a>BLE程序下载流程</h3><p><img src="/2020/01/14/ble/BLE%E7%A8%8B%E5%BA%8F%E4%B8%8B%E8%BD%BD%E6%B5%81%E7%A8%8B.jpg" alt="BLE程序下载流程"></p><h3 id="全片擦除芯片"><a href="#全片擦除芯片" class="headerlink" title="全片擦除芯片"></a>全片擦除芯片</h3><p>只有使用协议栈下载的编程算法才可以实现全片擦除，下载应用程序的编程算法是无法进行全片擦除的</p><p>编程算法设置为协议栈编程算法</p><p><img src="/2020/01/14/ble/%E5%85%A8%E7%89%87%E6%93%A6%E9%99%A4%E7%AE%97%E6%B3%95.jpg" alt="全片擦除算法"></p><p>执行flash-&gt;earse</p><p>如果在裸机程序中执行了全片擦除，擦除完成后，再将编程算法改成应用程序的编程算法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;nRF52832-BLE&quot;&gt;&lt;a href=&quot;#nRF52832-BLE&quot; class=&quot;headerlink&quot; title=&quot;nRF52832 BLE&quot;&gt;&lt;/a&gt;nRF52832 BLE&lt;/h1&gt;&lt;p&gt;随着物联网的发展，BLE蓝牙正在被广泛使用，几乎BLE配个安卓app已然成为现在物联网产品的标配，如小米手环，小米智能家居，小米电饭煲，更多的医疗产品。从技术角度看，与stm32嵌入式开发一般，并无大的区别，主要是加蓝牙协议，而不是单纯的单片机。NRF52832是我入门的第一款BLE蓝牙，所以我打算记录下我的学习过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Iot" scheme="https://liu-yaohua.github.io/categories/Iot/"/>
    
    
      <category term="ble" scheme="https://liu-yaohua.github.io/tags/ble/"/>
    
  </entry>
  
  <entry>
    <title>java</title>
    <link href="https://liu-yaohua.github.io/2020/01/14/java/"/>
    <id>https://liu-yaohua.github.io/2020/01/14/java/</id>
    <published>2020-01-14T07:26:29.000Z</published>
    <updated>2020-01-20T05:30:06.175Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java入门"><a href="#java入门" class="headerlink" title="java入门"></a>java入门</h1><h2 id="java的诞生"><a href="#java的诞生" class="headerlink" title="java的诞生"></a>java的诞生</h2><p>java语言相对于其他语言的最大优势就是所谓的平台无关性，即跨平台。无论哪种编程语言编写的应用程序都需要经过操作系统和处理器来完成程序运行，因此这里指的平台是由操作系统（OS）和处理器（CPU）所构成。与平台无关是指软件的运行不因操作系统、处理器的变化导致发生无法运行或者出现运行错误。平台最终识别并且执行的是一种由0和1组成的序列代码，我们称之为机器指令。相同的cpu和不同的操作系统所形成的平台的机器指令可能也不是相同的。</p><a id="more"></a><p>java之所以能与平台无关是因为java可以在平台之上再提供一个java运行环境，该java运行环境是由java虚拟机、类库以及一些核心文件组成。java虚拟机的核心是所谓的字节码指令，即可以被java虚拟机直接识别、执行的一种由0和1组成的序列代码。字节码并不是机器指令，因为它不和特定的平台相关，不能被任何平台直接识别和执行。java针对不同平台提供的java虚拟机的字节码指令都 是相同的。</p><h2 id="java环境安装"><a href="#java环境安装" class="headerlink" title="java环境安装"></a>java环境安装</h2><p>百度搜索java jdk下载安装，注意不是jre，然后配置环境变量。</p><p>安装完成后，在bin目录下，javac是编译器，java是解析器</p><h2 id="java-helloworld"><a href="#java-helloworld" class="headerlink" title="java helloworld"></a>java helloworld</h2><h3 id="1-应用程序的主类"><a href="#1-应用程序的主类" class="headerlink" title="1.应用程序的主类"></a>1.应用程序的主类</h3><p>一个java应用程序可以由若干个java源文件所构成，每个源文件又可以由若干个书写形式互相独立的类组成，但其中一个源文件必须有一个类含有public static void main(String args[])方法，这个类称之为这个应用程序的主类。args[]是main方法的一个参数，是一个字符串类型的数组。所有的java应用程序都是从主类的main开始执行。</p><h3 id="2-源文件的命名"><a href="#2-源文件的命名" class="headerlink" title="2.源文件的命名"></a>2.源文件的命名</h3><p>源文件的名字与类的名字相同，扩展名是.java。注意大小写，因为java区分大小写。同时java有着一些命名规范，但并不会强制要求这样写：</p><ol><li><p>包的命名：全部小写（com.blue）</p></li><li><p>类的命名：单词首字母大写（Hello）</p></li><li><p>方法的命名：首字母小写，后面的单词首字母大写（getName）</p></li><li><p>常量的命名：全部大写，常加入下划线(MAX_VALUE)</p><p>在桌面新建一个文件夹javaDemo，新建Hello.java，写入以下内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打cmd窗口</p><p>编译：javac Hello.java</p><p>解析执行：java Hello(主类名) </p></li></ol><h3 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3.数据类型"></a>3.数据类型</h3><p>float型数据，如3.14f，一定要加f </p><h3 id="4-常量"><a href="#4-常量" class="headerlink" title="4.常量"></a>4.常量</h3><p>用final关键词修饰</p><h3 id="5-类"><a href="#5-类" class="headerlink" title="5.类"></a>5.类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> speed;<span class="comment">//变量声明部分，刻画速度</span></span><br><span class="line"><span class="keyword">int</span> power;<span class="comment">//变量声明部分，刻画功率</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">speedUp</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">speed = speed - s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">speedDown</span><span class="params">(<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">speed = speed - d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setPower</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">power = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getPower</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> power;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getSpeed</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> speed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类是面向对象语言中最重要的一种数据类型，那么就可以用它来声明变量。在面向对象语言中，用类声明的变量被称作对象。和基本数据类型不同，在用类声明对象后，还必须要创建对象，即为声明的对象分配变量（确定对象所具有的属性），当使用一个类创建一个对象时，也称给出了这个类的一个实例。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>1、如果局部变量的名字与成员变量的名字相同，则成员变量被隐藏，即这个成员变量在这个方法内暂时失效。如果想在该方法中使用被隐藏的成员变量，必须使用关键字this。</p><p>2、类体的内容由两部分构成：一部分是变量的声明，另一部分是方法的定义。对成员变量的操作只能放在方法中，方法可以对成员变量和该方法体中声明的局部变量进行操作。在声明成员变量是可以同时赋予初值，但是不可以在类体中有单独的赋值语句。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;java入门&quot;&gt;&lt;a href=&quot;#java入门&quot; class=&quot;headerlink&quot; title=&quot;java入门&quot;&gt;&lt;/a&gt;java入门&lt;/h1&gt;&lt;h2 id=&quot;java的诞生&quot;&gt;&lt;a href=&quot;#java的诞生&quot; class=&quot;headerlink&quot; title=&quot;java的诞生&quot;&gt;&lt;/a&gt;java的诞生&lt;/h2&gt;&lt;p&gt;java语言相对于其他语言的最大优势就是所谓的平台无关性，即跨平台。无论哪种编程语言编写的应用程序都需要经过操作系统和处理器来完成程序运行，因此这里指的平台是由操作系统（OS）和处理器（CPU）所构成。与平台无关是指软件的运行不因操作系统、处理器的变化导致发生无法运行或者出现运行错误。平台最终识别并且执行的是一种由0和1组成的序列代码，我们称之为机器指令。相同的cpu和不同的操作系统所形成的平台的机器指令可能也不是相同的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://liu-yaohua.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://liu-yaohua.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>cmake</title>
    <link href="https://liu-yaohua.github.io/2020/01/13/cmake/"/>
    <id>https://liu-yaohua.github.io/2020/01/13/cmake/</id>
    <published>2020-01-13T08:23:38.000Z</published>
    <updated>2020-01-14T03:33:08.502Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CMake的应用与实践"><a href="#CMake的应用与实践" class="headerlink" title="CMake的应用与实践"></a>CMake的应用与实践</h1><a id="more"></a><h2 id="1-认识CMake及应用"><a href="#1-认识CMake及应用" class="headerlink" title="1.认识CMake及应用"></a>1.认识CMake及应用</h2><h3 id="CMake是什么？"><a href="#CMake是什么？" class="headerlink" title="CMake是什么？"></a>CMake是什么？</h3><p>全称Cross Platform Make，起初为了跨平台需要，而后不断完善并广泛使用。</p><p>一款优秀的工程构建工具</p><h3 id="特点及优势："><a href="#特点及优势：" class="headerlink" title="特点及优势："></a>特点及优势：</h3><p>开放源码</p><p>跨平台，支持Linux,Mac和Windows等</p><p>编译语言简单，易用，简化编译构建过程和编译过程</p><p>编程高效，可扩展</p><h3 id="CMake与其他编译工具的对比"><a href="#CMake与其他编译工具的对比" class="headerlink" title="CMake与其他编译工具的对比"></a>CMake与其他编译工具的对比</h3><h4 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h4><p>由GNU开发的编程语言译器，C/C++，Java等语言开发</p><p>当项目简单，可以gcc/g++编译目标和项目</p><p>但比较复杂时，只用gcc组织编译架构变得极其困难</p><h4 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h4><p>Makefile是有条理的gcc编译命令的文件，利用make工具来执行Makefile文件的编译指令</p><p>当程序简单，可以手写Makefile</p><p>当程序复杂时，一般利用CMake和autotools来自动生成Makefile</p><h4 id="Autotools"><a href="#Autotools" class="headerlink" title="Autotools"></a>Autotools</h4><p>autotools是一个工具集，具有灵活性较大，对用户角度使用较为友好</p><p>开发步骤太，配置繁琐</p><p>通常编译的./configure文件，大多通过由autotools构建的，最终生成Makefile和config.h文件</p><h4 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h4><p>Cmake类似Make工具功能，用来读取并执行CMakeList.txt文件的语句，最终生成Makefile文件</p><p>Cmake语言开发相对简单，易于理解</p><p>目前很多项目正在抛弃Autotools,qmake等，转而采用cmake</p><h2 id="2-CMake实战"><a href="#2-CMake实战" class="headerlink" title="2.CMake实战"></a>2.CMake实战</h2><h3 id="1-同一个目录，单个源文件"><a href="#1-同一个目录，单个源文件" class="headerlink" title="1.同一个目录，单个源文件"></a>1.同一个目录，单个源文件</h3><p>工程结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./Demo1</span><br><span class="line">|</span><br><span class="line">+---main.cc</span><br></pre></td></tr></table></figure><p>对应Cmake文件如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#CMake 最低版本号要求</span><br><span class="line">cmake_minimum_required(VERSION <span class="number">2.8</span>)</span><br><span class="line">#项目信息</span><br><span class="line">project(Demo1)</span><br><span class="line">#指定生成目标</span><br><span class="line">add_executable(Demo1 main.cc)</span><br></pre></td></tr></table></figure><p>CMakeLists.txt 的语法比较简单，由命令、注释和空格组成，其中命令是不区分大小写的。符号 <code>#</code> 后面的内容被认为是注释。命令由命令名称、小括号和参数组成，参数之间使用空格进行间隔。</p><p>对于上面的 CMakeLists.txt 文件，依次出现了几个命令：</p><ol><li><code>cmake_minimum_required</code>：指定运行此配置文件所需的 CMake 的最低版本；</li><li><code>project</code>：参数值是 <code>Demo1</code>，该命令表示项目的名称是 <code>Demo1</code> 。</li><li><code>add_executable</code>： 将名为 <a href="http://main.cc/" target="_blank" rel="external nofollow noopener noreferrer">main.cc</a> 的源文件编译成一个名称为 Demo 的可执行文件。</li></ol><p>编译项目</p><p>之后，在当前目录执行 <code>cmake .</code> ，得到 Makefile 后再使用 <code>make</code> 命令编译得到 Demo1 可执行文件。</p><p>其实说白了，cmake是为了生成makefile文件，再用make指令来执行makefile文件，即编译</p><p>用cmake就可以简化写makefile的过程。</p><h3 id="2-同一个目录，多个源文件"><a href="#2-同一个目录，多个源文件" class="headerlink" title="2.同一个目录，多个源文件"></a>2.同一个目录，多个源文件</h3><p>工程结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">./Demo2</span><br><span class="line"></span><br><span class="line">|</span><br><span class="line"></span><br><span class="line">+--- main.cc</span><br><span class="line"></span><br><span class="line">|</span><br><span class="line"></span><br><span class="line">+--- MathFunctions.cc</span><br><span class="line"></span><br><span class="line">|</span><br><span class="line"></span><br><span class="line">+--- MathFunctions.h</span><br></pre></td></tr></table></figure><p>对应Cmake如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># CMake 最低版本号要求</span><br><span class="line"></span><br><span class="line">cmake_minimum_required (VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"># 项目信息</span><br><span class="line"></span><br><span class="line">project (Demo2)</span><br><span class="line"></span><br><span class="line"># 指定生成目标</span><br><span class="line"></span><br><span class="line">add_executable(Demo2 main.cc MathFunctions.cc)</span><br></pre></td></tr></table></figure><p>唯一的改动只是在 <code>add_executable</code> 命令中增加了一个 <code>MathFunctions.cc</code> 源文件。这样写当然没什么问题，但是如果源文件很多，把所有源文件的名字都加进去将是一件烦人的工作。更省事的方法是使用 <code>aux_source_directory</code> 命令，该命令会查找指定目录下的所有源文件，然后将结果存进指定变量名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aux_source_directory(&lt;dir&gt; &lt;variable&gt;)</span><br></pre></td></tr></table></figure><p>因此，可以修改 CMakeLists.txt 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># CMake 最低版本号要求</span><br><span class="line"></span><br><span class="line">cmake_minimum_required (VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"># 项目信息</span><br><span class="line"></span><br><span class="line">project (Demo2)</span><br><span class="line"></span><br><span class="line"># 查找当前目录下的所有源文件</span><br><span class="line"></span><br><span class="line"># 并将名称保存到 DIR_SRCS 变量</span><br><span class="line"></span><br><span class="line">aux_source_directory(. DIR_SRCS)</span><br><span class="line"></span><br><span class="line"># 指定生成目标</span><br><span class="line"></span><br><span class="line">add_executable(Demo2 $&#123;DIR_SRCS&#125;)</span><br></pre></td></tr></table></figure><h3 id="3-多个目录，多个源文件"><a href="#3-多个目录，多个源文件" class="headerlink" title="3.多个目录，多个源文件"></a>3.多个目录，多个源文件</h3><p>工程结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">./Demo3</span><br><span class="line"></span><br><span class="line">|</span><br><span class="line"></span><br><span class="line">+--- main.cc</span><br><span class="line"></span><br><span class="line">|</span><br><span class="line"></span><br><span class="line">+--- math/</span><br><span class="line"></span><br><span class="line">|</span><br><span class="line"></span><br><span class="line">+--- MathFunctions.cc</span><br><span class="line"></span><br><span class="line">|</span><br><span class="line"></span><br><span class="line">+--- MathFunctions.h</span><br></pre></td></tr></table></figure><p>对于这种情况，需要分别在项目根目录 Demo3 和 math 目录里各编写一个 CMakeLists.txt 文件。为了方便，我们可以先将 math 目录里的文件编译成静态库再由 main 函数调用。</p><p>根目录中的 CMakeLists.txt ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># CMake 最低版本号要求</span><br><span class="line"></span><br><span class="line">cmake_minimum_required (VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"># 项目信息</span><br><span class="line"></span><br><span class="line">project (Demo3)</span><br><span class="line"></span><br><span class="line"># 查找当前目录下的所有源文件</span><br><span class="line"></span><br><span class="line"># 并将名称保存到 DIR_SRCS 变量</span><br><span class="line"></span><br><span class="line">aux_source_directory(. DIR_SRCS)</span><br><span class="line"></span><br><span class="line"># 添加 math 子目录</span><br><span class="line"></span><br><span class="line">add_subdirectory(math)</span><br><span class="line"></span><br><span class="line"># 指定生成目标</span><br><span class="line"></span><br><span class="line">add_executable(Demo main.cc)</span><br><span class="line"></span><br><span class="line"># 添加链接库</span><br><span class="line"></span><br><span class="line">target_link_libraries(Demo MathFunctions)</span><br></pre></td></tr></table></figure><p>该文件添加了下面的内容: 第3行，使用命令 <code>add_subdirectory</code> 指明本项目包含一个子目录 math，这样 math 目录下的 CMakeLists.txt 文件和源代码也会被处理 。第6行，使用命令 <code>target_link_libraries</code> 指明可执行文件 main 需要连接一个名为 MathFunctions 的链接库 。</p><p>子目录中的 CMakeLists.txt：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 查找当前目录下的所有源文件</span><br><span class="line"></span><br><span class="line"># 并将名称保存到 DIR_LIB_SRCS 变量</span><br><span class="line"></span><br><span class="line">aux_source_directory(. DIR_LIB_SRCS)</span><br><span class="line"></span><br><span class="line"># 生成链接库</span><br><span class="line"></span><br><span class="line">add_library (MathFunctions $&#123;DIR_LIB_SRCS&#125;)</span><br></pre></td></tr></table></figure><p>在该文件中使用命令 <code>add_library</code> 将 src 目录中的源文件编译为静态链接库。</p><h3 id="3-自定义编译选项"><a href="#3-自定义编译选项" class="headerlink" title="3.自定义编译选项"></a>3.自定义编译选项</h3><p>CMake 允许为项目增加编译选项，从而可以根据用户的环境和需求选择最合适的编译方案。</p><p>例如，可以将 MathFunctions 库设为一个可选的库，如果该选项为 <code>ON</code> ，就使用该库定义的数学函数来进行运算。否则就调用标准库中的数学函数库。</p><p>修改 CMakeLists 文件</p><p>我们要做的第一步是在顶层的 CMakeLists.txt 文件中添加该选项：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"># CMake 最低版本号要求</span><br><span class="line"></span><br><span class="line">cmake_minimum_required (VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"># 项目信息</span><br><span class="line"></span><br><span class="line">project (Demo4)</span><br><span class="line"></span><br><span class="line"># 加入一个配置头文件，用于处理 CMake 对源码的设置</span><br><span class="line"></span><br><span class="line">configure_file (</span><br><span class="line"></span><br><span class="line"><span class="string">"$&#123;PROJECT_SOURCE_DIR&#125;/config.h.in"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"$&#123;PROJECT_BINARY_DIR&#125;/config.h"</span></span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 是否使用自己的 MathFunctions 库</span><br><span class="line"></span><br><span class="line">option (USE_MYMATH</span><br><span class="line"></span><br><span class="line"><span class="string">"Use provided math implementation"</span> ON)</span><br><span class="line"></span><br><span class="line"># 是否加入 MathFunctions 库</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (USE_MYMATH)</span><br><span class="line"></span><br><span class="line">include_directories (<span class="string">"$&#123;PROJECT_SOURCE_DIR&#125;/math"</span>)</span><br><span class="line"></span><br><span class="line">add_subdirectory (math)</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> (EXTRA_LIBS $&#123;EXTRA_LIBS&#125; MathFunctions)</span><br><span class="line"></span><br><span class="line">endif (USE_MYMATH)</span><br><span class="line"></span><br><span class="line"># 查找当前目录下的所有源文件</span><br><span class="line"></span><br><span class="line"># 并将名称保存到 DIR_SRCS 变量</span><br><span class="line"></span><br><span class="line">aux_source_directory(. DIR_SRCS)</span><br><span class="line"></span><br><span class="line"># 指定生成目标</span><br><span class="line"></span><br><span class="line">add_executable(Demo $&#123;DIR_SRCS&#125;)</span><br><span class="line"></span><br><span class="line">target_link_libraries (Demo $&#123;EXTRA_LIBS&#125;)</span><br></pre></td></tr></table></figure><p><code>configure_file</code> 命令用于加入一个配置头文件 config.h ，这个文件由 CMake 从 <a href="http://config.h.in/" target="_blank" rel="external nofollow noopener noreferrer">config.h.in</a> 生成，通过这样的机制，将可以通过预定义一些参数和变量来控制代码的生成。<code>option</code> 命令添加了一个 <code>USE_MYMATH</code> 选项，并且默认值为 <code>ON</code> 。根据 <code>USE_MYMATH</code> 变量的值来决定是否使用我们自己编写的 MathFunctions 库。</p><p>修改 <a href="http://main.cc/" target="_blank" rel="external nofollow noopener noreferrer">main.cc</a> 文件</p><p>之后修改 <a href="http://main.cc/" target="_blank" rel="external nofollow noopener noreferrer">main.cc</a> 文件，让其根据 <code>USE_MYMATH</code> 的预定义值来决定是否调用标准库还是 MathFunctions 库：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"config.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_MYMATH</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"math/MathFunctions.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argc &lt; <span class="number">3</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Usage: %s base exponent \n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> base = atof(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> exponent = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_MYMATH</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Now we use our own Math library. \n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> result = power(base, exponent);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Now we use the standard library. \n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> result = <span class="built_in">pow</span>(base, exponent);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%g ^ %d is %g\n"</span>, base, exponent, result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写 <a href="http://config.h.in/" target="_blank" rel="external nofollow noopener noreferrer">config.h.in</a> 文件</p><p>这个文件预定义了 <code>USE_MYMATH</code> 的值。但我们并不直接编写这个文件，为了方便从 CMakeLists.txt 中导入配置，我们编写一个 <a href="http://config.h.in/" target="_blank" rel="external nofollow noopener noreferrer">config.h.in</a> 文件，内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#cmakedefine USE_MYMATH</span></span><br></pre></td></tr></table></figure><p>这样 CMake 会自动根据 CMakeLists 配置文件中的设置自动生成 config.h 文件。</p><h3 id="4-库"><a href="#4-库" class="headerlink" title="4.库"></a>4.库</h3><p>在 Linux 中，库文件分成静态库和共享库两种x。静态库以.a 作为后缀名，共享库以.so 结尾。所有库都是一些函数打包后的集合，差别在于静态库每次被调用都会生成一个副本， 而共享库则只有一个副本，更省空间。</p><p>生成静态库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_library( hello libHelloSLAM.cpp )</span><br></pre></td></tr></table></figure><p>生成动态库：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_library( hello_shared SHARED libHelloSLAM.cpp )</span><br></pre></td></tr></table></figure><p>此时得到的文件是 libhello_shared.so 了。</p><p>库文件是一个压缩包，里头带有编译好的二进制函数。不过，仅有.a 或.so 库文件的 话，我们并不知道它里头的函数到底是什么，调用的形式又是什么样的。为了让别人(或 者自己)使用这个库，我们需要提供一个头文件，说明这些库里都有些什么。因此，对于库 的使用者，只要拿到了头文件和库文件，就可以调用这个库了。下面我们来写 libhello 的<br>头文件。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CMake的应用与实践&quot;&gt;&lt;a href=&quot;#CMake的应用与实践&quot; class=&quot;headerlink&quot; title=&quot;CMake的应用与实践&quot;&gt;&lt;/a&gt;CMake的应用与实践&lt;/h1&gt;
    
    </summary>
    
    
      <category term="program" scheme="https://liu-yaohua.github.io/categories/program/"/>
    
    
      <category term="cmake" scheme="https://liu-yaohua.github.io/tags/cmake/"/>
    
  </entry>
  
  <entry>
    <title>re-thread2</title>
    <link href="https://liu-yaohua.github.io/2020/01/11/rt-thread2/"/>
    <id>https://liu-yaohua.github.io/2020/01/11/rt-thread2/</id>
    <published>2020-01-11T09:41:24.000Z</published>
    <updated>2020-01-11T14:34:44.666Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2020/01/11/rt-thread2/head.jpg" alt></p><a id="more"></a><h1 id="RT-Thread内核应用开发"><a href="#RT-Thread内核应用开发" class="headerlink" title="RT-Thread内核应用开发"></a>RT-Thread内核应用开发</h1><h3 id="RT-Thread文件夹简介"><a href="#RT-Thread文件夹简介" class="headerlink" title="RT-Thread文件夹简介"></a>RT-Thread文件夹简介</h3><h4 id="bsp文件夹"><a href="#bsp文件夹" class="headerlink" title="bsp文件夹"></a>bsp文件夹</h4><p>bsp 文件夹里面存放的是板级支持包，即board support package 的英文缩写，也就是相应开发板的驱动程序。bsp 文件夹下面的board.c这是RT-Thread 用来初始化开发板硬件的相关函数。rtconfig.h 是RT-Thread 功能的配置头文件，里面定义了很多宏，通过这些宏定义，我们可以裁剪RT-Thread 的功能。用户在使用RT-Thread 的时候，用户只需要修改board.c 和rtconfig.h 这两个文件的内容即可，其它文件我们不需要改动。如果为了减小工程的大小，bsp 文件夹下面除了board.c 和rtconfig.h这两个文件要保留外，其它的统统可以删除。</p><h4 id="components文件夹"><a href="#components文件夹" class="headerlink" title="components文件夹"></a>components文件夹</h4><p>在RT-Thread 看来，除了内核，其它第三方加进来的软件都是组件，比如gui、fatfs、lwip 和finsh 等，那么这些组件就放在components 这个文件夹内。finsh 是RT-Thread 组件里面最具特色的，它通过串口打印的方式来输出各种信息，方便我们调试程序。</p><h4 id="include文件夹"><a href="#include文件夹" class="headerlink" title="include文件夹"></a>include文件夹</h4><p>include 目录下面存放的是RT-Thread 内核的头文件，是内核不可分割的一部分。</p><h4 id="libcpu文件夹"><a href="#libcpu文件夹" class="headerlink" title="libcpu文件夹"></a>libcpu文件夹</h4><p>RT-Thread 是一个软件，单片机是一个硬件，RT-Thread 要想运行在一个单片机上面，它们就必须关联在一起，那么怎么关联？还是得通过写代码来关联，这部分关联的文件叫接口文件，通常由汇编和C 联合编写。这些接口文件都是跟硬件密切相关的，不同的硬件接口文件是不一样的，但都大同小异。编写这些接口文件的过程我们就叫移植，移植的过程通常由RT-Thread 和mcu 原厂的人来负责，移植好的这些接口文件就放在libcpu 这个文件夹的目录下。RT-Thread nano 目前在libcpu 目录下只放了cortex-m0、m3、m4 和m7 内核的单片机的接口文件，只要是使用了这些内核的mcu 都可以使用里面的接口文件。通常网络上出现的叫“移植某某某RTOS 到某某某MCU”的教程，其实准确来说，不能够叫移植，应该叫使用官方的移植，因为这些跟硬件相关的接口文件，RTOS 官方都已经写好了，我们只是使用而已。</p><h4 id="src文件夹"><a href="#src文件夹" class="headerlink" title="src文件夹"></a>src文件夹</h4><p>src 目录下面存放的是RT-Thread 内核的源文件，是内核的核心。</p><h4 id="keil工程结构"><a href="#keil工程结构" class="headerlink" title="keil工程结构"></a>keil工程结构</h4><p>在开发环境里面新建rtt/source 和rtt/ports 两个组文件夹，其中rtt/source 用于存放src 文件夹的内容，rtt/ports 用于存放libcpu/arm/cortex-m？文件夹的内容，“？”表示3、4 或者7。bsp 里面的rtconfig.h 和board.c 添加到user 组文件夹下，其中rtconfig.h 用于配置RTThread的功能，board.c 用于存放硬件相关的初始化函数。</p><p><img src="/2020/01/11/rt-thread2/keil.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2020/01/11/rt-thread2/head.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="rt-thread" scheme="https://liu-yaohua.github.io/categories/rt-thread/"/>
    
    
      <category term="learning" scheme="https://liu-yaohua.github.io/tags/learning/"/>
    
  </entry>
  
  <entry>
    <title>hello</title>
    <link href="https://liu-yaohua.github.io/2020/01/10/hello/"/>
    <id>https://liu-yaohua.github.io/2020/01/10/hello/</id>
    <published>2020-01-10T10:09:23.000Z</published>
    <updated>2020-01-10T14:39:03.155Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2020/01/10/hello/ylj.jpg" alt></p><a id="more"></a><p>总有一天，会有一个人，看你写过的所有状态，读完写的所有微博，看你从小到大的所有照片，甚至去别的地方寻找关于你的信息，试着听你听的歌，走你走过的地方，看你喜欢看的书，品尝你总是大呼好吃的东西……只是想弥补上，你的青春。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2020/01/10/hello/ylj.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="emotion" scheme="https://liu-yaohua.github.io/tags/emotion/"/>
    
  </entry>
  
  <entry>
    <title>rt-thread内核</title>
    <link href="https://liu-yaohua.github.io/2020/01/10/rt-thread/"/>
    <id>https://liu-yaohua.github.io/2020/01/10/rt-thread/</id>
    <published>2020-01-10T07:20:20.000Z</published>
    <updated>2020-01-11T09:40:41.666Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2020/01/10/rt-thread/zz.jpg" alt></p><a id="more"></a><h2 id="嵌入式系统和RT-Thread"><a href="#嵌入式系统和RT-Thread" class="headerlink" title="嵌入式系统和RT-Thread"></a>嵌入式系统和RT-Thread</h2><p>在裸机系统中，所有的程序基本都是自己写的，所有的操作都是在一个无限的大循环里面实现。现实生活中的很多中小型的电子产品用的都是裸机系统，而且也能够满足需求。但是为什么还要学习RTOS 编程，偏偏还要整个操作系统进来。一是项目需要，随着产品要实现的功能越来越多，单纯的裸机系统已经不能够完美地解决问题，反而会使编程变得更加复杂，如果想降低编程的难度，我们可以考虑引入RTOS 实现多线程管理，这是使用RTOS 的最大优势。二是学习的需要，必须学习更高级的东西，实现更好的职业规划，为将来走向人生巅峰迎娶白富美做准备，而不是一味的在裸机编程上面死磕。作为一个合格的嵌入式软件工程师，学习是永远不能停歇的事，时刻都得为将来准备。书到用时方恨少，我希望机会来临时你不要有这种感觉。</p><p>可偏偏在10 几年前，在中国，有一个天赋异禀，倔强不屈的极客，他叫熊谱翔，编写了RT-Thread 初代内核，并联合中国开源社区的极客不断完善，推陈出新，经过10 几年的发展，如今占据国产RTOS 的鳌头，每年递增数十万的开发者，加上如今AI 和物联网等风口，让RT-Thread 有一统江湖之势，从今年完成A 轮数百万美元的融资就可以看出，在未来不出5 年，RT-Thread 将是你学习和做产品的不二之选。</p><h2 id="裸机系统和多线程系统"><a href="#裸机系统和多线程系统" class="headerlink" title="裸机系统和多线程系统"></a>裸机系统和多线程系统</h2><h3 id="裸机系统"><a href="#裸机系统" class="headerlink" title="裸机系统"></a>裸机系统</h3><p>裸机系统通常分成轮询系统和前后台系统</p><h5 id="轮询系统"><a href="#轮询系统" class="headerlink" title="轮询系统"></a>轮询系统</h5><p>轮询系统即是在裸机编程的时候，先初始化好相关的硬件，然后让主程序在一个死循环里面不断环，顺序地做各种事情。轮询系统是一种非常简单的软件结构，通常只适用于那些只需要顺序执行代码且不需要外部事件来驱动的就能完成的事情。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="comment">/* 硬件相关初始化 */</span></span><br><span class="line">  HardWareInit();</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* 无限循环 */</span></span><br><span class="line"> <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">  <span class="comment">/* 处理事情1 */</span></span><br><span class="line"> DoSomething1();</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* 处理事情2 */</span></span><br><span class="line">         DoSomething2();</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* 处理事情3 */</span></span><br><span class="line">         DoSomething3();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="前后台系统"><a href="#前后台系统" class="headerlink" title="前后台系统"></a>前后台系统</h5><p>相比轮询系统，前后台系统是在轮询系统的基础上加入了中断。外部事件的响应在中断里面完成，事件的处理还是回到轮询系统中完成，中断在这里我们称为前台，main 函数里面的无限循环我们称为后台。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">int</span> flag1 = <span class="number">0</span>;</span><br><span class="line"><span class="number">2</span> <span class="keyword">int</span> flag2 = <span class="number">0</span>;</span><br><span class="line"><span class="number">3</span> <span class="keyword">int</span> flag3 = <span class="number">0</span>;</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">6 </span>&#123;</span><br><span class="line"><span class="number">7</span> <span class="comment">/* 硬件相关初始化 */</span></span><br><span class="line"><span class="number">8</span> HardWareInit();</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span> <span class="comment">/* 无限循环 */</span></span><br><span class="line"><span class="number">11</span> <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="number">12</span> <span class="keyword">if</span> (flag1) &#123;</span><br><span class="line"><span class="number">13</span> <span class="comment">/* 处理事情1 */</span></span><br><span class="line"><span class="number">14</span> DoSomething1();</span><br><span class="line"><span class="number">15</span> &#125;</span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">17</span> <span class="keyword">if</span> (flag2) &#123;</span><br><span class="line"><span class="number">18</span> <span class="comment">/* 处理事情2 */</span></span><br><span class="line"><span class="number">19</span> DoSomething2();</span><br><span class="line"><span class="number">20</span> &#125;</span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">22</span> <span class="keyword">if</span> (flag3) &#123;</span><br><span class="line"><span class="number">23</span> <span class="comment">/* 处理事情3 */</span></span><br><span class="line"><span class="number">24</span> DoSomething3();</span><br><span class="line"><span class="number">25</span> &#125;</span><br><span class="line"><span class="number">26</span> &#125;</span><br><span class="line"><span class="number">27</span> &#125;</span><br><span class="line"><span class="number">28</span></span><br><span class="line"><span class="number">29</span> <span class="function"><span class="keyword">void</span> <span class="title">ISR1</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">30 </span>&#123;</span><br><span class="line"><span class="number">31</span> <span class="comment">/* 置位标志位 */</span></span><br><span class="line"><span class="number">32</span> flag1 = <span class="number">1</span>;</span><br><span class="line"><span class="number">33</span> <span class="comment">/* 如果事件处理时间很短，则在中断里面处理</span></span><br><span class="line"><span class="comment">34 如果事件处理时间比较长，在回到前台处理 */</span></span><br><span class="line"><span class="number">35</span> DoSomething1();</span><br><span class="line"><span class="number">36</span> &#125;</span><br><span class="line"><span class="number">37</span></span><br><span class="line"><span class="number">38</span> <span class="function"><span class="keyword">void</span> <span class="title">ISR2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">39 </span>&#123;</span><br><span class="line"><span class="number">40</span> <span class="comment">/* 置位标志位 */</span></span><br><span class="line"><span class="number">41</span> flag2 = <span class="number">1</span>;</span><br><span class="line"><span class="number">42</span></span><br><span class="line"><span class="number">43</span> <span class="comment">/* 如果事件处理时间很短，则在中断里面处理</span></span><br><span class="line"><span class="comment">44 如果事件处理时间比较长，在回到前台处理 */</span></span><br><span class="line"><span class="number">45</span> DoSomething2();</span><br><span class="line"><span class="number">46</span> &#125;</span><br><span class="line"><span class="number">47</span></span><br><span class="line"><span class="number">48</span> <span class="function"><span class="keyword">void</span> <span class="title">ISR3</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">49 </span>&#123;</span><br><span class="line"><span class="number">50</span> <span class="comment">/* 置位标志位 */</span></span><br><span class="line"><span class="number">51</span> flag3 = <span class="number">1</span>;</span><br><span class="line"><span class="number">52</span></span><br><span class="line"><span class="number">53</span> <span class="comment">/* 如果事件处理时间很短，则在中断里面处理</span></span><br><span class="line"><span class="comment">54 如果事件处理时间比较长，在回到前台处理 */</span></span><br><span class="line"><span class="number">55</span> DoSomething3();</span><br><span class="line"><span class="number">56</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="多线程系统"><a href="#多线程系统" class="headerlink" title="多线程系统"></a>多线程系统</h3><p>相比前后台系统，多线程系统的事件响应也是在中断中完成的，但是事件的处理是在线程中完成的。在多线程系统中，线程跟中断一样，也具有优先级，优先级高的线程会被优先执行。当一个紧急的事件在中断被标记之后，如果事件对应的线程的优先级足够高，就会立马得到响应。相比前后台系统，多线程系统的实时性又被提高了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">int</span> flag1 = <span class="number">0</span>;</span><br><span class="line"><span class="number">2</span> <span class="keyword">int</span> flag2 = <span class="number">0</span>;</span><br><span class="line"><span class="number">3</span> <span class="keyword">int</span> flag3 = <span class="number">0</span>;</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">6 </span>&#123;</span><br><span class="line"><span class="number">7</span> <span class="comment">/* 硬件相关初始化 */</span></span><br><span class="line"><span class="number">8</span> HardWareInit();</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span> <span class="comment">/* OS 初始化 */</span></span><br><span class="line"><span class="number">11</span> RTOSInit();</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span> <span class="comment">/* OS 启动，开始多线程调度，不再返回 */</span></span><br><span class="line"><span class="number">14</span> RTOSStart();</span><br><span class="line"><span class="number">15</span> &#125;</span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">17</span> <span class="function"><span class="keyword">void</span> <span class="title">ISR1</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">18 </span>&#123;</span><br><span class="line"><span class="number">19</span> <span class="comment">/* 置位标志位 */</span></span><br><span class="line"><span class="number">20</span> flag1 = <span class="number">1</span>;</span><br><span class="line"><span class="number">21</span> &#125;</span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">23</span> <span class="function"><span class="keyword">void</span> <span class="title">ISR2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">24 </span>&#123;</span><br><span class="line"><span class="number">25</span> <span class="comment">/* 置位标志位 */</span></span><br><span class="line"><span class="number">26</span> flag2 = <span class="number">2</span>;</span><br><span class="line"><span class="number">27</span> &#125;</span><br><span class="line"><span class="number">28</span></span><br><span class="line"><span class="number">29</span> <span class="function"><span class="keyword">void</span> <span class="title">ISR3</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">30 </span>&#123;</span><br><span class="line"><span class="number">31</span> <span class="comment">/* 置位标志位 */</span></span><br><span class="line"><span class="number">32</span> flag3 = <span class="number">1</span>;</span><br><span class="line"><span class="number">33</span> &#125;</span><br><span class="line"><span class="number">34</span></span><br><span class="line"><span class="number">35</span> <span class="function"><span class="keyword">void</span> <span class="title">DoSomething1</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">36 </span>&#123;</span><br><span class="line"><span class="number">37</span> <span class="comment">/* 无限循环，不能返回 */</span></span><br><span class="line"><span class="number">38</span> <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="number">39</span> <span class="comment">/* 线程实体 */</span></span><br><span class="line"><span class="number">40</span> <span class="keyword">if</span> (flag1) &#123;</span><br><span class="line"><span class="number">41</span></span><br><span class="line"><span class="number">42</span> &#125;</span><br><span class="line"><span class="number">43</span> &#125;</span><br><span class="line"><span class="number">44</span> &#125;</span><br><span class="line"><span class="number">45</span></span><br><span class="line"><span class="number">46</span> <span class="function"><span class="keyword">void</span> <span class="title">DoSomething2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">47 </span>&#123;</span><br><span class="line"><span class="number">48</span> <span class="comment">/* 无限循环，不能返回 */</span></span><br><span class="line"><span class="number">49</span> <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="number">50</span> <span class="comment">/* 线程实体 */</span></span><br><span class="line"><span class="number">51</span> <span class="keyword">if</span> (flag2) &#123;</span><br><span class="line"><span class="number">52</span></span><br><span class="line"><span class="number">53</span> &#125;</span><br><span class="line"><span class="number">54</span> &#125;</span><br><span class="line"><span class="number">55</span> &#125;</span><br><span class="line"><span class="number">56</span></span><br><span class="line"><span class="number">57</span> <span class="function"><span class="keyword">void</span> <span class="title">DoSomething3</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">58 </span>&#123;</span><br><span class="line"><span class="number">59</span> <span class="comment">/* 无限循环，不能返回 */</span></span><br><span class="line"><span class="number">60</span> <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="number">61</span> <span class="comment">/* 线程实体 */</span></span><br><span class="line"><span class="number">62</span> <span class="keyword">if</span> (flag3) &#123;</span><br><span class="line"><span class="number">63</span></span><br><span class="line"><span class="number">64</span> &#125;</span><br><span class="line"><span class="number">65</span> &#125;</span><br><span class="line"><span class="number">66</span> &#125;</span><br></pre></td></tr></table></figure><p>相比前后台系统中后台顺序执行的程序主体，在多线程系统中，根据程序的功能，我们把这个程序主体分割成一个个独立的，无限循环且不能返回的小程序，这个小程序我们称之为线程。每个线程都是独立的，互不干扰的，且具备自身的优先级，它由操作系统调度管理。加入操作系统后，我们在编程的时候不需要精心地去设计程序的执行流，不用担心每个功能模块之间是否存在干扰。加入了操作系统，我们的编程反而变得简单了。整个系统随之带来的额外开销就是操作系统占据的那一丁点FLASH 和RAM。现如今，单片机的FLASH 和RAM是越来越大，完全足以抵挡RTOS 那点开销。</p><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>在裸机系统中，系统的主体就是main 函数里面顺序执行的无限循环，这个无限循环里面CPU 按照顺序完成各种事情。在多线程系统中，我们根据功能的不同，把整个系统分割成一个个独立的且无法返回的函数，这个函数我们称为线程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">void</span> <span class="title">thread_entry</span> <span class="params">(<span class="keyword">void</span> *parg)</span></span></span><br><span class="line"><span class="function">2 </span>&#123;</span><br><span class="line"><span class="number">3</span> <span class="comment">/* 线程主体，无限循环且不能返回 */</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="number">5</span> <span class="comment">/* 线程主体代码 */</span></span><br><span class="line"><span class="number">6</span> &#125;</span><br><span class="line"><span class="number">7</span> &#125;</span><br></pre></td></tr></table></figure><h4 id="线程栈"><a href="#线程栈" class="headerlink" title="线程栈"></a>线程栈</h4><p>在多线程系统中，每个线程都是独立的，互不干扰的，所以要为每个线程都分配独立的栈空间，这个栈空间通常是一个预先定义好的全局数组，也可以是动态分配的一段内存空间，但它们都存在于RAM 中。在多线程系统中，有多少个线程就需要定义多少个线程栈。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义线程栈 */</span></span><br><span class="line"><span class="keyword">rt_uint8_t</span> rt_flag1_thread_stack[<span class="number">512</span>]; (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">rt_uint8_t</span> rt_flag2_thread_stack[<span class="number">512</span>];</span><br></pre></td></tr></table></figure><h4 id="线程控制块"><a href="#线程控制块" class="headerlink" title="线程控制块"></a>线程控制块</h4><p>在裸机系统中，程序的主体是CPU 按照顺序执行的。而在多线程系统中，线程的执行是由系统调度的。系统为了顺利的调度线程，为每个线程都额外定义了一个线程控制块，这个线程控制块就相当于线程的身份证，里面存有线程的所有信息，比如线程的栈指针，线程名称，线程的形参等。有了这个线程控制块之后，以后系统对线程的全部操作都可以通过这个线程控制块来实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function">struct <span class="title">rt_thread</span> <span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">2 </span>&#123;</span><br><span class="line"><span class="number">3</span> <span class="keyword">void</span> *sp; <span class="comment">/* 线程栈指针 */</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">void</span> *entry; <span class="comment">/* 线程入口地址 */</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">void</span> *parameter; <span class="comment">/* 线程形参 */</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">void</span> *stack_addr; <span class="comment">/* 线程栈起始地址 */</span></span><br><span class="line"><span class="number">7</span> <span class="keyword">rt_uint32_t</span> stack_size; <span class="comment">/* 线程栈大小，单位为字节 */</span></span><br><span class="line"><span class="number">8</span> &#125;;</span><br><span class="line"><span class="number">9</span> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> *<span class="title">rt_thread_t</span>;</span> (<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h4 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h4><p>线程的栈，线程的函数实体，线程的控制块最终需要联系起来才能由系统进行统一调度。那么这个联系的工作就由线程初始化函数rt_thread_init()来实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">rt_err_t</span> rt_thread_init(struct rt_thread *thread, (<span class="number">1</span>)</span><br><span class="line"><span class="number">2</span> <span class="keyword">void</span> (*entry)(<span class="keyword">void</span> *parameter), (<span class="number">2</span>)</span><br><span class="line"><span class="number">3</span> <span class="keyword">void</span> *parameter, (<span class="number">3</span>)</span><br><span class="line"><span class="number">4</span> <span class="keyword">void</span> *stack_start, (<span class="number">4</span>)</span><br><span class="line"><span class="number">5</span> <span class="keyword">rt_uint32_t</span> stack_size) (<span class="number">5</span>)</span><br><span class="line"><span class="number">6</span> &#123;</span><br><span class="line"><span class="number">7</span> rt_list_init(&amp;(thread-&gt;tlist)); (<span class="number">6</span>)</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span> thread-&gt;entry = (<span class="keyword">void</span> *)entry; (<span class="number">7</span>)</span><br><span class="line"><span class="number">10</span> thread-&gt;parameter = parameter; (<span class="number">8</span>)</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span> thread-&gt;stack_addr = stack_start; (<span class="number">9</span>)</span><br><span class="line"><span class="number">13</span> thread-&gt;stack_size = stack_size; (<span class="number">10</span>)</span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">15</span> <span class="comment">/* 初始化线程栈，并返回线程栈指针 */</span> (<span class="number">11</span>)</span><br><span class="line"><span class="number">16</span> thread-&gt;sp =</span><br><span class="line"><span class="number">17</span> (<span class="keyword">void</span> *)rt_hw_stack_init( thread-&gt;entry,</span><br><span class="line"><span class="number">18</span> thread-&gt;parameter,</span><br><span class="line"><span class="number">19</span> (<span class="keyword">void</span> *)((<span class="keyword">char</span> *)thread-&gt;stack_addr + thread-&gt;stack_size - <span class="number">4</span>) );</span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">21</span> <span class="keyword">return</span> RT_EOK; (<span class="number">12</span>)</span><br><span class="line"><span class="number">22</span> &#125;</span><br></pre></td></tr></table></figure><p>在main 函数中创建两个flag 相关的线程实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">2 </span>&#123;</span><br><span class="line"><span class="number">3</span> <span class="comment">/* 硬件初始化 */</span></span><br><span class="line"><span class="number">4</span> <span class="comment">/* 将硬件相关的初始化放在这里，如果是软件仿真则没有相关初始化代码 */</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span> <span class="comment">/* 初始化线程 */</span></span><br><span class="line"><span class="number">8</span> rt_thread_init( &amp;rt_flag1_thread, <span class="comment">/* 线程控制块 */</span></span><br><span class="line"><span class="number">9</span> flag1_thread_entry, <span class="comment">/* 线程入口地址 */</span></span><br><span class="line"><span class="number">10</span> RT_NULL, <span class="comment">/* 线程形参 */</span></span><br><span class="line"><span class="number">11</span> &amp;rt_flag1_thread_stack[<span class="number">0</span>], <span class="comment">/* 线程栈起始地址 */</span></span><br><span class="line"><span class="number">12</span> <span class="keyword">sizeof</span>(rt_flag1_thread_stack) ); <span class="comment">/* 线程栈大小，单位为字节</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span> <span class="comment">/* 初始化线程 */</span></span><br><span class="line"><span class="number">15</span> rt_thread_init( &amp;rt_flag2_thread, <span class="comment">/* 线程控制块 */</span></span><br><span class="line"><span class="number">16</span> flag2_thread_entry, <span class="comment">/* 线程入口地址 */</span></span><br><span class="line"><span class="number">17</span> RT_NULL, <span class="comment">/* 线程形参 */</span></span><br><span class="line"><span class="number">18</span> &amp;rt_flag2_thread_stack[<span class="number">0</span>], <span class="comment">/* 线程栈起始地址 */</span></span><br><span class="line"><span class="number">19</span> <span class="keyword">sizeof</span>(rt_flag2_thread_stack) ); <span class="comment">/* 线程栈大小，单位为字节 */</span></span><br></pre></td></tr></table></figure><h4 id="就绪列表"><a href="#就绪列表" class="headerlink" title="就绪列表"></a>就绪列表</h4><p>线程创建好之后，我们需要把线程添加到就绪列表里面，表示线程已经就绪，系统随时可以调度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="comment">/* 线程就绪列表 */</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rt_list_t</span> rt_thread_priority_table[RT_THREAD_PRIORITY_MAX]; (<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>线程控制块里面有一个tlist 成员，数据类型为rt_list_t，我们将线程插入到就绪列表里面，就是通过将线程控制块的tlist 这个节点插入到就绪列表中来实现的。如果把就绪列表比作是晾衣杆，线程是衣服，那tlist 就是晾衣架，每个线程都自带晾衣架，就是为了把自己挂在各种不同的链表中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="comment">/* 初始化线程 */</span></span><br><span class="line"><span class="number">2</span> rt_thread_init( &amp;rt_flag1_thread, <span class="comment">/* 线程控制块 */</span></span><br><span class="line"><span class="number">3</span> flag1_thread_entry, <span class="comment">/* 线程入口地址 */</span></span><br><span class="line"><span class="number">4</span> RT_NULL, <span class="comment">/* 线程形参 */</span></span><br><span class="line"><span class="number">5</span> &amp;rt_flag1_thread_stack[<span class="number">0</span>], <span class="comment">/* 线程栈起始地址 */</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">sizeof</span>(rt_flag1_thread_stack) ); <span class="comment">/* 线程栈大小，单位为字节 */</span></span><br><span class="line"><span class="number">7</span> <span class="comment">/* 将线程插入到就绪列表 */</span></span><br><span class="line"><span class="number">8</span> rt_list_insert_before( &amp;(rt_thread_priority_table[<span class="number">0</span>]),&amp;(rt_flag1_thread.tlist) );</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span> <span class="comment">/* 初始化线程 */</span></span><br><span class="line"><span class="number">11</span> rt_thread_init( &amp;rt_flag2_thread, <span class="comment">/* 线程控制块 */</span></span><br><span class="line"><span class="number">12</span> flag2_thread_entry, <span class="comment">/* 线程入口地址 */</span></span><br><span class="line"><span class="number">13</span> RT_NULL, <span class="comment">/* 线程形参 */</span></span><br><span class="line"><span class="number">14</span> &amp;rt_flag2_thread_stack[<span class="number">0</span>], <span class="comment">/* 线程栈起始地址 */</span></span><br><span class="line"><span class="number">15</span> <span class="keyword">sizeof</span>(rt_flag2_thread_stack) ); <span class="comment">/* 线程栈大小，单位为字节 */</span></span><br><span class="line"><span class="number">16</span> <span class="comment">/* 将线程插入到就绪列表 */</span></span><br><span class="line"><span class="number">17</span> rt_list_insert_before( &amp;(rt_thread_priority_table[<span class="number">1</span>]),&amp;(rt_flag2_thread.tlist) );</span><br></pre></td></tr></table></figure><h4 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h4><p>调度器是操作系统的核心，其主要功能就是实现线程的切换，即从就绪列表里面找到优先级最高的线程，然后去执行该线程。</p><p>调度器在使用之前必须先初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="comment">/* 初始化系统调度器 */</span></span><br><span class="line"><span class="number">2</span> <span class="function"><span class="keyword">void</span> <span class="title">rt_system_scheduler_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">3 </span>&#123;</span><br><span class="line"><span class="number">4</span> <span class="keyword">register</span> <span class="keyword">rt_base_t</span> offset; (<span class="number">1</span>)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span> <span class="comment">/* 线程就绪列表初始化 */</span></span><br><span class="line"><span class="number">8</span> <span class="keyword">for</span> (offset = <span class="number">0</span>; offset &lt; RT_THREAD_PRIORITY_MAX; offset ++) (<span class="number">2</span>)</span><br><span class="line"><span class="number">9</span> &#123;</span><br><span class="line"><span class="number">10</span> rt_list_init(&amp;rt_thread_priority_table[offset]);</span><br><span class="line"><span class="number">11</span> &#125;</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span> <span class="comment">/* 初始化当前线程控制块指针 */</span></span><br><span class="line"><span class="number">14</span> rt_current_thread = RT_NULL; (<span class="number">3</span>)</span><br><span class="line"><span class="number">15</span> &#125;</span><br></pre></td></tr></table></figure><p>我们把调度器初始化放在硬件初始化之后，线程创建之前:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">2 </span>&#123;</span><br><span class="line"><span class="number">3</span> <span class="comment">/* 硬件初始化 */</span></span><br><span class="line"><span class="number">4</span> <span class="comment">/* 将硬件相关的初始化放在这里，如果是软件仿真则没有相关初始化代码 */</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span> <span class="comment">/* 调度器初始化 */</span></span><br><span class="line"><span class="number">7</span> rt_system_scheduler_init();</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span> <span class="comment">/* 初始化线程 */</span></span><br><span class="line"><span class="number">11</span> rt_thread_init( &amp;rt_flag1_thread, <span class="comment">/* 线程控制块 */</span></span><br><span class="line"><span class="number">12</span> flag1_thread_entry, <span class="comment">/* 线程入口地址 */</span></span><br><span class="line"><span class="number">13</span> RT_NULL, <span class="comment">/* 线程形参 */</span></span><br><span class="line"><span class="number">14</span> &amp;rt_flag1_thread_stack[<span class="number">0</span>], <span class="comment">/* 线程栈起始地址 */</span></span><br><span class="line"><span class="number">15</span> <span class="keyword">sizeof</span>(rt_flag1_thread_stack) ); <span class="comment">/* 线程栈大小，单位为字节 */</span></span><br><span class="line"><span class="number">16</span> <span class="comment">/* 将线程插入到就绪列表 */</span></span><br><span class="line"><span class="number">17</span> rt_list_insert_before( &amp;(rt_thread_priority_table[<span class="number">0</span>]),&amp;(rt_flag1_thread.tlist) );</span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">19</span> <span class="comment">/* 初始化线程 */</span></span><br><span class="line"><span class="number">20</span> rt_thread_init( &amp;rt_flag2_thread, <span class="comment">/* 线程控制块 */</span></span><br><span class="line"><span class="number">21</span> flag2_thread_entry, <span class="comment">/* 线程入口地址 */</span></span><br><span class="line"><span class="number">22</span> RT_NULL, <span class="comment">/* 线程形参 */</span></span><br><span class="line"><span class="number">23</span> &amp;rt_flag2_thread_stack[<span class="number">0</span>], <span class="comment">/* 线程栈起始地址 */</span></span><br><span class="line"><span class="number">24</span> <span class="keyword">sizeof</span>(rt_flag2_thread_stack) ); <span class="comment">/* 线程栈大小，单位为字节 */</span></span><br><span class="line"><span class="number">25</span> <span class="comment">/* 将线程插入到就绪列表 */</span></span><br><span class="line"><span class="number">26</span> rt_list_insert_before( &amp;(rt_thread_priority_table[<span class="number">1</span>]),&amp;(rt_flag2_thread.tlist) );</span><br><span class="line"><span class="number">27</span> &#125;</span><br></pre></td></tr></table></figure><p>初始化调度器后，我们就可以启动调度器啦，调度器启动由函数rt_system_scheduler_start()来完成。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="comment">/* 启动系统调度器 */</span></span><br><span class="line"><span class="number">2</span> <span class="function"><span class="keyword">void</span> <span class="title">rt_system_scheduler_start</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">3 </span>&#123;</span><br><span class="line"><span class="number">4</span> <span class="keyword">register</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> *<span class="title">to_thread</span>;</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span> <span class="comment">/* 手动指定第一个运行的线程 */</span> (<span class="number">1</span>)</span><br><span class="line"><span class="number">8</span> to_thread = rt_list_entry(rt_thread_priority_table[<span class="number">0</span>].next,</span><br><span class="line"><span class="number">9</span> struct rt_thread,</span><br><span class="line"><span class="number">10</span> tlist);</span><br><span class="line"><span class="number">11</span> rt_current_thread = to_thread; (<span class="number">2</span>)</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span> <span class="comment">/* 切换到第一个线程，该函数在context_rvds.S 中实现，</span></span><br><span class="line"><span class="comment">14 在rthw.h 声明，用于实现第一次线程切换。</span></span><br><span class="line"><span class="comment">15 当一个汇编函数在C 文件中调用的时候，如果有形参，</span></span><br><span class="line"><span class="comment">16 则执行的时候会将形参传人到CPU 寄存器r0。*/</span></span><br><span class="line"><span class="number">17</span> rt_hw_context_switch_to((<span class="keyword">rt_uint32_t</span>)&amp;to_thread-&gt;sp); (<span class="number">3</span>)</span><br><span class="line"><span class="number">18</span> &#125;</span><br></pre></td></tr></table></figure><h4 id="临界段"><a href="#临界段" class="headerlink" title="临界段"></a>临界段</h4><p>临界段用一句话概括就是一段在执行的时候不能被中断的代码段。在RT-Thread 里面，这个临界段最常出现的就是对全局变量的操作，全局变量就好像是一个枪把子，谁都可以对他开枪，但是我开枪的时候，你就不能开枪，否则就不知道是谁命中了靶子。那么什么情况下临界段会被打断？一个是系统调度，还有一个就是外部中断。在RTThread，系统调度，最终也是产生PendSV 中断，在PendSV Handler 里面实现线程的切换，所以还是可以归结为中断。既然这样，RT-Thread 对临界段的保护就处理的很干脆了，直接把中断全部关了，NMI FAULT 和硬FAULT 除外。</p><h4 id="对象容器"><a href="#对象容器" class="headerlink" title="对象容器"></a>对象容器</h4><p>在RT-Thread 中，所有的数据结构都称之为对象。其中线程，信号量，互斥量、事件、邮箱、消息队列、内存堆、内存池、设备和定时器在rtdef.h 中有明显的枚举定义，即为每个对象打上了一个数字标签。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">enum</span> rt_object_class_type</span><br><span class="line"><span class="number">2</span> &#123;</span><br><span class="line"><span class="number">3</span> RT_Object_Class_Thread = <span class="number">0</span>, <span class="comment">/* 对象是线程 */</span></span><br><span class="line"><span class="number">4</span> RT_Object_Class_Semaphore, <span class="comment">/* 对象是信号量 */</span></span><br><span class="line"><span class="number">5</span> RT_Object_Class_Mutex, <span class="comment">/* 对象是互斥量 */</span></span><br><span class="line"><span class="number">6</span> RT_Object_Class_Event, <span class="comment">/* 对象是事件 */</span></span><br><span class="line"><span class="number">7</span> RT_Object_Class_MailBox, <span class="comment">/* 对象是邮箱 */</span></span><br><span class="line"><span class="number">8</span> RT_Object_Class_MessageQueue, <span class="comment">/* 对象是消息队列 */</span></span><br><span class="line"><span class="number">9</span> RT_Object_Class_MemHeap, <span class="comment">/* 对象是内存堆 */</span></span><br><span class="line"><span class="number">10</span> RT_Object_Class_MemPool, <span class="comment">/* 对象是内存池 */</span></span><br><span class="line"><span class="number">11</span> RT_Object_Class_Device, <span class="comment">/* 对象是设备 */</span></span><br><span class="line"><span class="number">12</span> RT_Object_Class_Timer, <span class="comment">/* 对象是定时器 */</span></span><br><span class="line"><span class="number">13</span> RT_Object_Class_Module, <span class="comment">/* 对象是模块 */</span></span><br><span class="line"><span class="number">14</span> RT_Object_Class_Unknown, <span class="comment">/* 对象未知 */</span></span><br><span class="line"><span class="number">15</span> RT_Object_Class_Static = <span class="number">0x80</span> <span class="comment">/* 对象是静态对象 */</span></span><br><span class="line"><span class="number">16</span> &#125;;</span><br></pre></td></tr></table></figure><h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><p>在rtt 中，每当用户创建一个对象，如线程，就会将这个对象放到一个叫做容器的地方，这样做的目的是为了方便管理，管理什么？在RT-Thread 的组件finsh 的使用中，就需要使用到容器，通过扫描容器的内核对象来获取各个内核对象的状态，然后输出调试信息。</p><p>从代码上看，容器就是一个数组，是一个全局变量，数据类型为struct_rt_object_information，在object.c 中定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">static</span> struct <span class="title">rt_object_information</span> <span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line">2 rt_object_container[RT_Object_Info_Unknown] = &#123; (2)</span><br><span class="line"><span class="number">3</span> <span class="comment">/* 初始化对象容器 - 线程 */</span> (<span class="number">3</span>)</span><br><span class="line"><span class="number">4</span> &#123;</span><br><span class="line"><span class="number">5</span> RT_Object_Class_Thread, (<span class="number">3</span>)-①</span><br><span class="line"><span class="number">6</span> _OBJ_CONTAINER_LIST_INIT(RT_Object_Info_Thread), (<span class="number">3</span>)-②</span><br><span class="line"><span class="number">7</span> <span class="keyword">sizeof</span>(struct rt_thread) (<span class="number">3</span>)-③</span><br><span class="line"><span class="number">8</span> &#125;,</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span> <span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_SEMAPHORE (4)</span></span><br><span class="line"><span class="number">11</span> <span class="comment">/* 初始化对象容器 - 信号量 */</span></span><br><span class="line"><span class="number">12</span> &#123;</span><br><span class="line"><span class="number">13</span> RT_Object_Class_Semaphore,</span><br><span class="line"><span class="number">14</span> _OBJ_CONTAINER_LIST_INIT(RT_Object_Info_Semaphore),</span><br><span class="line"><span class="number">15</span> <span class="keyword">sizeof</span>(struct rt_semaphore)</span><br><span class="line"><span class="number">16</span> &#125;,</span><br><span class="line"><span class="number">17</span> <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">19</span> <span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MUTEX (5)</span></span><br><span class="line"><span class="number">20</span> <span class="comment">/* 初始化对象容器 - 互斥量 */</span></span><br><span class="line"><span class="number">21</span> &#123;</span><br><span class="line"><span class="number">22</span> RT_Object_Class_Mutex,</span><br><span class="line"><span class="number">23</span> _OBJ_CONTAINER_LIST_INIT(RT_Object_Info_Mutex),</span><br><span class="line"><span class="number">24</span> <span class="keyword">sizeof</span>(struct rt_mutex)</span><br><span class="line"><span class="number">25</span> &#125;,</span><br><span class="line"><span class="number">26</span> <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="number">28</span> <span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_EVENT (6)</span></span><br><span class="line"><span class="number">29</span> <span class="comment">/* 初始化对象容器 - 事件 */</span></span><br><span class="line"><span class="number">30</span> &#123;</span><br><span class="line"><span class="number">31</span> RT_Object_Class_Event,</span><br><span class="line"><span class="number">32</span> _OBJ_CONTAINER_LIST_INIT(RT_Object_Info_Event),</span><br><span class="line"><span class="number">33</span> <span class="keyword">sizeof</span>(struct rt_event)</span><br><span class="line"><span class="number">34</span> &#125;,</span><br><span class="line"><span class="number">35</span> <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="number">36</span></span><br><span class="line"><span class="number">37</span> <span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MAILBOX (7)</span></span><br><span class="line"><span class="number">38</span> <span class="comment">/* 初始化对象容器 - 邮箱 */</span></span><br><span class="line"><span class="number">39</span> &#123;</span><br><span class="line"><span class="number">40</span> RT_Object_Class_MailBox,</span><br><span class="line"><span class="number">41</span> _OBJ_CONTAINER_LIST_INIT(RT_Object_Info_MailBox),</span><br><span class="line"><span class="number">42</span> <span class="keyword">sizeof</span>(struct rt_mailbox)</span><br><span class="line"><span class="number">43</span> &#125;,</span><br><span class="line"><span class="number">44</span> <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="number">45</span></span><br><span class="line"><span class="number">46</span> <span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MESSAGEQUEUE (8)</span></span><br><span class="line"><span class="number">47</span> <span class="comment">/* 初始化对象容器 - 消息队列 */</span></span><br><span class="line"><span class="number">48</span> &#123;</span><br><span class="line"><span class="number">49</span> RT_Object_Class_MessageQueue,</span><br><span class="line"><span class="number">50</span> _OBJ_CONTAINER_LIST_INIT(RT_Object_Info_MessageQueue),</span><br><span class="line"><span class="number">51</span> <span class="keyword">sizeof</span>(struct rt_messagequeue)</span><br><span class="line"><span class="number">52</span> &#125;,</span><br><span class="line"><span class="number">53</span> <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="number">54</span></span><br><span class="line"><span class="number">55</span> <span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MEMHEAP (9)</span></span><br><span class="line"><span class="number">56</span> <span class="comment">/* 初始化对象容器 - 内存堆 */</span></span><br><span class="line"><span class="number">57</span> &#123;</span><br><span class="line"><span class="number">58</span> RT_Object_Class_MemHeap,</span><br><span class="line"><span class="number">59</span> _OBJ_CONTAINER_LIST_INIT(RT_Object_Info_MemHeap),</span><br><span class="line"><span class="number">60</span> <span class="keyword">sizeof</span>(struct rt_memheap)</span><br><span class="line"><span class="number">61</span> &#125;,</span><br><span class="line"><span class="number">62</span> <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="number">63</span></span><br><span class="line"><span class="number">64</span> <span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MEMPOOL (10)</span></span><br><span class="line"><span class="number">65</span> <span class="comment">/* 初始化对象容器 - 内存池 */</span></span><br><span class="line"><span class="number">66</span> &#123;</span><br><span class="line"><span class="number">67</span> RT_Object_Class_MemPool,</span><br><span class="line"><span class="number">68</span> _OBJ_CONTAINER_LIST_INIT(RT_Object_Info_MemPool),</span><br><span class="line"><span class="number">69</span> <span class="keyword">sizeof</span>(struct rt_mempool)</span><br><span class="line"><span class="number">70</span> &#125;,</span><br><span class="line"><span class="number">71</span> <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="number">72</span></span><br><span class="line"><span class="number">73</span> <span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_DEVICE (11)</span></span><br><span class="line"><span class="number">74</span> <span class="comment">/* 初始化对象容器 - 设备 */</span></span><br><span class="line"><span class="number">75</span> &#123;</span><br><span class="line"><span class="number">76</span> RT_Object_Class_Device,</span><br><span class="line"><span class="number">77</span> _OBJ_CONTAINER_LIST_INIT(RT_Object_Info_Device),</span><br><span class="line"><span class="number">78</span> <span class="keyword">sizeof</span>(struct rt_device)</span><br><span class="line"><span class="number">79</span> &#125;,</span><br><span class="line"><span class="number">80</span> <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="number">81</span></span><br><span class="line"><span class="number">82</span> <span class="comment">/* 初始化对象容器 - 定时器 */</span> (<span class="number">12</span>)</span><br><span class="line"><span class="number">83</span> <span class="comment">/*</span></span><br><span class="line"><span class="comment">84 &#123;</span></span><br><span class="line"><span class="comment">85 RT_Object_Class_Timer,</span></span><br><span class="line"><span class="comment">86 _OBJ_CONTAINER_LIST_INIT(RT_Object_Info_Timer),</span></span><br><span class="line"><span class="comment">87 sizeof(struct rt_timer)</span></span><br><span class="line"><span class="comment">88 &#125;,</span></span><br><span class="line"><span class="comment">89 */</span></span><br><span class="line"><span class="number">90</span> <span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MODULE (13)</span></span><br><span class="line"><span class="number">91</span> <span class="comment">/* 初始化对象容器 - 模块 */</span></span><br><span class="line"><span class="number">92</span> &#123;</span><br><span class="line"><span class="number">93</span> RT_Object_Class_Module,</span><br><span class="line"><span class="number">94</span> _OBJ_CONTAINER_LIST_INIT(RT_Object_Info_Module),</span><br><span class="line"><span class="number">95</span> <span class="keyword">sizeof</span>(struct rt_module)</span><br><span class="line"><span class="number">96</span> &#125;,</span><br><span class="line"><span class="number">97</span> <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="number">98</span> &#125;;</span><br></pre></td></tr></table></figure><h4 id="对象初始化"><a href="#对象初始化" class="headerlink" title="对象初始化"></a>对象初始化</h4><p>每创建一个对象，都需要先将其初始化，主要分成两个部分的工作，首先将对象控制块里面与对象相关的成员初始化，然后将该对象插入到对象容器中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="comment">/**</span></span><br><span class="line"><span class="comment">2 * 该函数将初始化对象并将对象添加到对象容器中</span></span><br><span class="line"><span class="comment">3 *</span></span><br><span class="line"><span class="comment">4 * @param object 要初始化的对象</span></span><br><span class="line"><span class="comment">5 * @param type 对象的类型</span></span><br><span class="line"><span class="comment">6 * @param name 对象的名字，在整个系统中，对象的名字必须是唯一的</span></span><br><span class="line"><span class="comment">7 */</span></span><br><span class="line"><span class="number">8</span> <span class="function"><span class="keyword">void</span> <span class="title">rt_object_init</span><span class="params">(struct rt_object *object, (<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">9</span> <span class="keyword">enum</span> rt_object_class_type type, (<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">10</span> <span class="keyword">const</span> <span class="keyword">char</span> *name)</span> <span class="params">(<span class="number">3</span>)</span></span></span><br><span class="line"><span class="function">11 </span>&#123;</span><br><span class="line"><span class="number">12</span> <span class="keyword">register</span> <span class="keyword">rt_base_t</span> temp;</span><br><span class="line"><span class="number">13</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_object_information</span> *<span class="title">information</span>;</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">15</span> <span class="comment">/* 获取对象信息，即从容器里拿到对应对象列表头指针 */</span></span><br><span class="line"><span class="number">16</span> information = rt_object_get_information(type); (<span class="number">4</span>)</span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">18</span> <span class="comment">/* 设置对象类型为静态 */</span></span><br><span class="line"><span class="number">19</span> object-&gt;type = type | RT_Object_Class_Static; (<span class="number">5</span>)</span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">21</span> <span class="comment">/* 拷贝名字 */</span></span><br><span class="line"><span class="number">22</span> rt_strncpy(object-&gt;name, name, RT_NAME_MAX); (<span class="number">6</span>)</span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="number">24</span> <span class="comment">/* 关中断 */</span></span><br><span class="line"><span class="number">25</span> temp = rt_hw_interrupt_disable(); (<span class="number">7</span>)</span><br><span class="line"><span class="number">26</span></span><br><span class="line"><span class="number">27</span> <span class="comment">/* 将对象插入到容器的对应列表中，不同类型的对象所在的列表不一样 */</span></span><br><span class="line"><span class="number">28</span> rt_list_insert_after(&amp;(information-&gt;object_list), &amp;(object-&gt;<span class="built_in">list</span>)); (<span class="number">8</span>)</span><br><span class="line"><span class="number">29</span></span><br><span class="line"><span class="number">30</span> <span class="comment">/* 使能中断 */</span></span><br><span class="line"><span class="number">31</span> rt_hw_interrupt_enable(temp); (<span class="number">9</span>)</span><br><span class="line"><span class="number">32</span> &#125;</span><br></pre></td></tr></table></figure><p>对象初始化函数在线程初始化函数里面被调用。</p><h4 id="空闲线程"><a href="#空闲线程" class="headerlink" title="空闲线程"></a>空闲线程</h4><p>线程体内的延时使用的是软件延时，即还是让CPU 空等来达到延时的效果。使用RTOS 的很大优势就是榨干CPU 的性能，永远不能让它闲着，线程如果需要延时也就不能再让CPU 空等来实现延时的效果。RTOS 中的延时叫阻塞延时，即线程需要延时的时候，线程会放弃CPU 的使用权，CPU 可以去干其它的事情，当线程延时时间到，重新获取CPU 使用权，线程继续运行，这样就充分地利用了CPU 的资源，而不是干等着。</p><p>当线程需要延时，进入阻塞状态，那CPU 又去干什么事情了？如果没有其它线程可以运行，RTOS 都会为CPU 创建一个空闲线程，这个时候CPU 就运行空闲线程。在RTThread中，空闲线程是系统在初始化的时候创建的优先级最低的线程，空闲线程主体主要是做一些系统内存的清理工作。鉴于空闲线程的这种特性，在实际应用中，当系统进入空闲线程的时候，可在空闲线程中让单片机进入休眠或者低功耗等操作。</p><p>空闲线程也是线程，其定义方法和普通线程定义方法一样。</p><h5 id="定义空闲线程栈"><a href="#定义空闲线程栈" class="headerlink" title="定义空闲线程栈"></a>定义空闲线程栈</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;rtthread.h&gt;</span></span></span><br><span class="line"><span class="number">2</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;rthw.h&gt;</span></span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="meta">#<span class="meta-keyword">define</span> IDLE_THREAD_STACK_SIZE 512</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span> ALIGN(RT_ALIGN_SIZE)</span><br><span class="line"><span class="number">7</span> <span class="keyword">static</span> <span class="keyword">rt_uint8_t</span> rt_thread_stack[IDLE_THREAD_STACK_SIZE];</span><br></pre></td></tr></table></figure><h5 id="定义空闲线程的线程控制块"><a href="#定义空闲线程的线程控制块" class="headerlink" title="定义空闲线程的线程控制块"></a>定义空闲线程的线程控制块</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 空闲线程的线程控制块 */</span></span><br><span class="line"><span class="number">1</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> <span class="title">idle</span>;</span></span><br></pre></td></tr></table></figure><h5 id="定义空闲线程函数"><a href="#定义空闲线程函数" class="headerlink" title="定义空闲线程函数"></a>定义空闲线程函数</h5><p>在RT-Thread 中空闲线程函数主要是做一些系统内存的清理工作，但是为了简单起见，我们实现的空闲线程只是对一个全局变量rt_idletask_ctr 进行计数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">rt_ubase_t</span> rt_idletask_ctr = <span class="number">0</span>;</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="function"><span class="keyword">void</span> <span class="title">rt_thread_idle_entry</span><span class="params">(<span class="keyword">void</span> *parameter)</span></span></span><br><span class="line"><span class="function">4 </span>&#123;</span><br><span class="line"><span class="number">5</span> parameter = parameter;</span><br><span class="line"><span class="number">6</span> <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line"><span class="number">7</span> &#123;</span><br><span class="line"><span class="number">8</span> rt_idletask_ctr ++;</span><br><span class="line"><span class="number">9</span> &#125;</span><br><span class="line"><span class="number">10</span> &#125;</span><br></pre></td></tr></table></figure><h5 id="空闲线程初始化"><a href="#空闲线程初始化" class="headerlink" title="空闲线程初始化"></a>空闲线程初始化</h5><p>当定义好空闲线程的栈，线程控制块和函数主体之后，我们需要空闲线程初始化函数将这三者联系在一起，这样空闲线程才能够被系统调度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">void</span> <span class="title">rt_thread_idle_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">2 </span>&#123;</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="comment">/* 初始化线程 */</span> (<span class="number">1</span>)</span><br><span class="line"><span class="number">5</span> rt_thread_init(&amp;idle,</span><br><span class="line"><span class="number">6</span> <span class="string">"idle"</span>,</span><br><span class="line"><span class="number">7</span> rt_thread_idle_entry,</span><br><span class="line"><span class="number">8</span> RT_NULL,</span><br><span class="line"><span class="number">9</span> &amp;rt_thread_stack[<span class="number">0</span>],</span><br><span class="line"><span class="number">10</span> <span class="keyword">sizeof</span>(rt_thread_stack));</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span> <span class="comment">/* 将线程插入到就绪列表 */</span> (<span class="number">2</span>)</span><br><span class="line"><span class="number">13</span> rt_list_insert_before( &amp;(rt_thread_priority_table[RT_THREAD_PRIORITY_MAX<span class="number">-1</span>]),</span><br><span class="line"><span class="number">14</span> &amp;(idle.tlist) );</span><br><span class="line"><span class="number">15</span> &#125;</span><br></pre></td></tr></table></figure><h4 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a>时间片</h4><p>在RT-Thread 中，当同一个优先级下有两个或两个以上线程的时候，线程支持时间片功能，即我们可以指定线程持续运行一次的时间，单位为tick。假如有两个线程分别为线程2 和线程3，他们的优先级都为3，线程2 的时间片为2，线程3 的时间片为3。当执行到优先级为3 的线程时，会先执行线程2，直到线程2 的时间片耗完，然后再执行线程3。</p><p>本次博客主要记录rt-thread的内核学习，下一篇记录应用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2020/01/10/rt-thread/zz.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="learn" scheme="https://liu-yaohua.github.io/tags/learn/"/>
    
  </entry>
  
  <entry>
    <title>test</title>
    <link href="https://liu-yaohua.github.io/2020/01/08/test/"/>
    <id>https://liu-yaohua.github.io/2020/01/08/test/</id>
    <published>2020-01-08T13:15:47.000Z</published>
    <updated>2020-01-10T10:16:09.234Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2020/01/08/test/bg.jpg" alt></p><a id="more"></a><p>路很长，雾很浓，但是，如果肯保有一颗谦卑与洁净的心，一定会在前路上找到一个更为开阔的世界，在那里，生命另有一种无法言传的尊严与价值。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2020/01/08/test/bg.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>外骨骼控制</title>
    <link href="https://liu-yaohua.github.io/2020/01/08/exoskeleton1-1/"/>
    <id>https://liu-yaohua.github.io/2020/01/08/exoskeleton1-1/</id>
    <published>2020-01-07T16:00:00.000Z</published>
    <updated>2020-01-10T15:32:42.731Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2020/01/08/exoskeleton1-1/yourname.jpg" alt></p><a id="more"></a><p>与传统机器人系统相比，这类可穿戴智能装备的最大特点，是通过在穿戴者肌骨神经运动控制生物系统与智能机电控制系统之间建立有效的物理和认知交互，使得两者在感知、决策和执行等多个层面融合与互补，最终构建综合一体化的具有“人在环”和“共融”特点的协同运动系统。对于这种高度复杂的人机系统而言，穿戴者不是可穿戴智能装备“被动的乘客”，而是一种全新的难以建模的交互对象，更是其结构与控制系统的重要组成部分。在这种新型人机交互系统的协同运动控制中，穿戴者借助自身肌骨神经运动系统自然的认知决策和运动行为，主导或部分参与人机系统从行为决策、整体位姿到关节运动轨迹等各层面的认知决策和运动规划。而可穿戴智能装备则通过传感系统感知穿戴者的运动状态与意图，控制各关节执行器实现相应的关节运动控制和动力补偿，最终实现人机系统协同的肢体运动和与外部环境的交互行为。相比于传统机器人系统纯粹基于预设控制算法决策与运动控制，这种人机交互系统将人体亿万年进化获得的认知智能和自然运动行为，与日益完善的智能化机电系统的传感技术和机械运动控制技术结合。这使得外骨骼这类可穿戴智能装备在获得前所未有的仿生性和环境自适应性的同时，成为穿戴者感知系统的延伸与肢体运动功能的拓展或补充。</p><p>对于助力类的外骨骼，几乎所有的控制信号输入都来源于穿戴者，而且需要对穿戴者的运动有良好的跟踪性能。这就要求外骨骼机器人的传感器系统能够高效准确地从复杂交互信号中提取人体的运动意图。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2020/01/08/exoskeleton1-1/yourname.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="外骨骼项目" scheme="https://liu-yaohua.github.io/categories/%E5%A4%96%E9%AA%A8%E9%AA%BC%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="think" scheme="https://liu-yaohua.github.io/tags/think/"/>
    
  </entry>
  
</feed>
